<!DOCTYPE html>
<html lang="en">

<head>
    <script>
        // for search plugin notably
        const base_url = "https://janclemenslab.org/acvr/";
    </script>
    <script>
    const darkTheme = window.matchMedia("(prefers-color-scheme: dark)");
    darkTheme.onchange = (e) => {
        if (e.matches) {
            document.documentElement.classList.add("dark")
            localStorage.theme = 'dark';
        } else {
            document.documentElement.classList.remove("dark")
            localStorage.removeItem("theme")
        }
    };

    // On page load. Priotiry to lcaolStorage
    if (localStorage.theme === "dark") {
        document.documentElement.classList.add("dark")
    } else if (localStorage.theme === "light") {
        document.documentElement.classList.remove("dark")
    } else if (darkTheme.matches) {
        document.documentElement.classList.add("dark")
    } else {
        document.documentElement.classList.remove("dark")
    }

    // set the layout based on localStorage
    document.documentElement.classList.add(localStorage.getItem("html-layout") || "layout-fixed");
</script>


    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>API - acvr</title>
    


<title>API</title>









<link rel="canonical" href="https://janclemenslab.org/acvr/api/">


<!-- Open Graph (Facebook, LinkedIn) -->

<meta property="og:title" content="API">





<meta property="og:url" content="https://janclemenslab.org/acvr/api/">






<!-- Twitter Card -->

<meta name="twitter:title" content="API">






<!-- JSON-LD Structured Data -->



    <link rel="icon" href="../assets/acvr.svg">

    <link href="../css/base.css" rel="stylesheet">
    <link href="../css/geist.css" rel="stylesheet">

    
    

<link id="pygments-light" rel="stylesheet"
    href="../css/pygments/shadcn-light.css">
<link id="pygments-dark" rel="stylesheet"
    href="../css/pygments/github-dark.css"
    media="(prefers-color-scheme: dark)">


    
    <link href="../assets/_mkdocstrings.css" rel="stylesheet">

    

    <script src="../js/callbacks.js"></script>

    

    

    

</head>

<body
    class="text-foreground group/body overscroll-none font-sans antialiased [--footer-height:calc(var(--spacing)*14)] [--header-height:calc(var(--spacing)*14)] xl:[--footer-height:calc(var(--spacing)*24)] theme-default">
    <div id="inner-body" class="bg-background relative z-10 flex min-h-svh flex-col">
        <header class="bg-background sticky top-0 z-50 w-full" view-transition-name="header">
    <div class="container-wrapper 3xl:fixed:px-0 px-6">
        <div class="3xl:fixed:container flex h-(--header-height) items-center gap-2 **:data-[slot=separator]:!h-4">
            <button id="menu-button" data-slot="popover-trigger" onclick="onMobileMenuButtonClick(event)"
                class="group whitespace-nowrap rounded-md text-sm font-medium transition-all disabled:pointer-events-none disabled:opacity-50 [&amp;_svg]:pointer-events-none [&amp;_svg:not([class*='size-'])]:size-4 shrink-0 [&amp;_svg]:shrink-0 outline-none focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive hover:text-accent-foreground px-4 py-2 has-[&gt;svg]:px-3 extend-touch-target h-8 touch-manipulation items-center justify-start gap-2.5 !p-0 hover:bg-transparent focus-visible:bg-transparent focus-visible:ring-0 active:bg-transparent dark:hover:bg-transparent flex lg:hidden"
                type="button" aria-haspopup="dialog" aria-expanded="false" aria-controls="radix-«Rmplb»"
                data-state="closed">
                <div class="relative flex h-8 w-4 items-center justify-center">
                    <div class="relative size-4">
                        <!-- 16px x 16px -->
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" fill="none" stroke="currentColor"
                            stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <line x1="0" x2="16" y1="5" y2="5"
                                class="group-data-[state=open]:translate-y-[2.25px] group-data-[state=open]:-translate-x-[2.25px] group-data-[state=open]:rotate-45 transition-all duration-300 origin-center" />
                            <line x1="0" x2="16" y1="11" y2="11"
                                class="group-data-[state=open]:-translate-y-[2.25px] group-data-[state=open]:-translate-x-[2.25px] group-data-[state=open]:-rotate-45 transition-all duration-300 origin-center" />
                        </svg>
                    </div>

                    <span class="sr-only">Toggle Menu</span>
                </div>
                <span class="flex h-8 items-center text-lg leading-none font-medium">Menu</span>
            </button>
            <a data-slot="button"
                class="items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-all disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg:not([class*='size-'])]:size-5 shrink-0 [&_svg]:shrink-0 outline-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive hover:bg-accent hover:text-accent-foreground dark:hover:bg-accent/50 hidden h-8 lg:flex"
                href="https://janclemenslab.org/acvr/">
                <span class="size-8 flex flex-row justify-center items-center">
                    

<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 256 256"
    class="size-5">
    <rect width="256" height="256" fill="none"></rect>
    <line x1="208" y1="128" x2="128" y2="208" fill="none" stroke="currentColor" stroke-linecap="round"
        stroke-linejoin="round" stroke-width="32"></line>
    <line x1="192" y1="40" x2="40" y2="192" fill="none" stroke="currentColor" stroke-linecap="round"
        stroke-linejoin="round" stroke-width="32"></line>
</svg>


                </span>

                
                <h1 class="pr-2">acvr</h1>
                
            </a>
            
            <div class="ml-auto flex items-center gap-2 md:flex-1 md:justify-end">
                <div class="hidden w-full flex-1 md:flex md:w-auto md:flex-none">
                    <button data-slot="dialog-trigger" onclick="onSearchBarClick(event)"
    class="inline-flex items-center gap-2 whitespace-nowrap rounded-md text-sm transition-all disabled:pointer-events-none disabled:opacity-50 [&amp;_svg]:pointer-events-none [&amp;_svg:not([class*='size-'])]:size-4 shrink-0 [&amp;_svg]:shrink-0 outline-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive hover:bg-secondary/80 px-4 py-2 has-[&gt;svg]:px-3 bg-surface text-surface-foreground/60 dark:bg-card relative h-8 w-full justify-start pl-2.5 font-normal shadow-none sm:pr-12 md:w-40 lg:w-56 xl:w-64"
    type="button" aria-haspopup="dialog" aria-expanded="false" aria-controls="radix-«R66plb»" data-state="closed">
    <span class="text-muted-foreground hidden lg:inline-flex">Search documentation...</span>
    <span class="text-muted-foreground inline-flex lg:hidden">Search...</span>
    <div class="absolute top-1.5 right-1.5 hidden gap-1 sm:flex">
        <kbd
            class="bg-background text-muted-foreground pointer-events-none flex h-5 items-center justify-center gap-1 rounded border px-1 font-sans text-[0.7rem] font-medium select-none [&amp;_svg:not([class*='size-'])]:size-3">Ctrl</kbd><kbd
            class="bg-background text-muted-foreground pointer-events-none flex h-5 items-center justify-center gap-1 rounded border px-1 font-sans text-[0.7rem] font-medium select-none [&amp;_svg:not([class*='size-'])]:size-3 aspect-square">K</kbd>
    </div>
</button>
<dialog id="search-dialog" onclick="onSearchDialogClick(event)"
    class="fixed top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 bg-background rounded-lg shadow-lg border overflow-hidden p-0">
    <div class="w-lg gap-4">
        <div class="flex h-full w-full flex-col overflow-hidden rounded-md bg-popover text-popover-foreground">
            <div data-slot="command-input-wrapper" class="flex h-9 items-center gap-2 border-b px-3"><svg
                    xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none"
                    stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"
                    class="lucide lucide-search size-4 shrink-0 opacity-50">
                    <circle cx="11" cy="11" r="8"></circle>
                    <path d="m21 21-4.3-4.3"></path>
                </svg>
                <input data-slot="command-input"
                    class="placeholder:text-muted-foreground flex h-10 w-full rounded-md bg-transparent py-3 text-sm outline-hidden disabled:cursor-not-allowed disabled:opacity-50"
                    placeholder="Search documentation..." cmdk-input="" autocomplete="off" autocorrect="off"
                    spellcheck="false" aria-autocomplete="list" role="combobox" aria-expanded="true"
                    aria-controls="radix-«r1t6»" aria-labelledby="radix-«r1t7»" id="radix-«r1t8»" type="text" value=""
                    aria-activedescendant="radix-«r1th»" oninput="onInputHandler(event)">
            </div>
        </div>
        <div id="mkdocs-search-results">
            <!-- search results go there -->
        </div>
    </div>
</dialog>
<script>
    document.removeEventListener("keydown", searchShortcutHandler);
    document.addEventListener("keydown", searchShortcutHandler);
</script>
                </div>
                <div data-orientation="vertical" role="none" data-slot="separator"
                    class="bg-border shrink-0 data-[orientation=horizontal]:h-px data-[orientation=horizontal]:w-full data-[orientation=vertical]:h-full data-[orientation=vertical]:w-px ml-2 hidden lg:block">
                </div>
                <a target="_blank" rel="noreferrer" data-slot="button"
                    class="inline-flex items-center justify-center whitespace-nowrap text-sm font-medium transition-all disabled:pointer-events-none disabled:opacity-50 [&amp;_svg]:pointer-events-none [&amp;_svg:not([class*='size-'])]:size-4 shrink-0 [&amp;_svg]:shrink-0 outline-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive hover:bg-accent hover:text-accent-foreground dark:hover:bg-accent/50 rounded-md gap-1.5 px-3 has-[&gt;svg]:px-2.5 h-8 shadow-none"
                    href="https://github.com/janclemenslab/acvr">
                    <svg viewBox="0 0 438.549 438.549">
                        <path fill="currentColor"
                            d="M409.132 114.573c-19.608-33.596-46.205-60.194-79.798-79.8-33.598-19.607-70.277-29.408-110.063-29.408-39.781 0-76.472 9.804-110.063 29.408-33.596 19.605-60.192 46.204-79.8 79.8C9.803 148.168 0 184.854 0 224.63c0 47.78 13.94 90.745 41.827 128.906 27.884 38.164 63.906 64.572 108.063 79.227 5.14.954 8.945.283 11.419-1.996 2.475-2.282 3.711-5.14 3.711-8.562 0-.571-.049-5.708-.144-15.417a2549.81 2549.81 0 01-.144-25.406l-6.567 1.136c-4.187.767-9.469 1.092-15.846 1-6.374-.089-12.991-.757-19.842-1.999-6.854-1.231-13.229-4.086-19.13-8.559-5.898-4.473-10.085-10.328-12.56-17.556l-2.855-6.57c-1.903-4.374-4.899-9.233-8.992-14.559-4.093-5.331-8.232-8.945-12.419-10.848l-1.999-1.431c-1.332-.951-2.568-2.098-3.711-3.429-1.142-1.331-1.997-2.663-2.568-3.997-.572-1.335-.098-2.43 1.427-3.289 1.525-.859 4.281-1.276 8.28-1.276l5.708.853c3.807.763 8.516 3.042 14.133 6.851 5.614 3.806 10.229 8.754 13.846 14.842 4.38 7.806 9.657 13.754 15.846 17.847 6.184 4.093 12.419 6.136 18.699 6.136 6.28 0 11.704-.476 16.274-1.423 4.565-.952 8.848-2.383 12.847-4.285 1.713-12.758 6.377-22.559 13.988-29.41-10.848-1.14-20.601-2.857-29.264-5.14-8.658-2.286-17.605-5.996-26.835-11.14-9.235-5.137-16.896-11.516-22.985-19.126-6.09-7.614-11.088-17.61-14.987-29.979-3.901-12.374-5.852-26.648-5.852-42.826 0-23.035 7.52-42.637 22.557-58.817-7.044-17.318-6.379-36.732 1.997-58.24 5.52-1.715 13.706-.428 24.554 3.853 10.85 4.283 18.794 7.952 23.84 10.994 5.046 3.041 9.089 5.618 12.135 7.708 17.705-4.947 35.976-7.421 54.818-7.421s37.117 2.474 54.823 7.421l10.849-6.849c7.419-4.57 16.18-8.758 26.262-12.565 10.088-3.805 17.802-4.853 23.134-3.138 8.562 21.509 9.325 40.922 2.279 58.24 15.036 16.18 22.559 35.787 22.559 58.817 0 16.178-1.958 30.497-5.853 42.966-3.9 12.471-8.941 22.457-15.125 29.979-6.191 7.521-13.901 13.85-23.131 18.986-9.232 5.14-18.182 8.85-26.84 11.136-8.662 2.286-18.415 4.004-29.263 5.146 9.894 8.562 14.842 22.077 14.842 40.539v60.237c0 3.422 1.19 6.279 3.572 8.562 2.379 2.279 6.136 2.95 11.276 1.995 44.163-14.653 80.185-41.062 108.068-79.226 27.88-38.161 41.825-81.126 41.825-128.906-.01-39.771-9.818-76.454-29.414-110.049z">
                        </path>
                    </svg>
                    
                </a>
                <div data-orientation="vertical" role="none" data-slot="separator"
                    class="bg-border shrink-0 data-[orientation=horizontal]:h-px data-[orientation=horizontal]:w-full data-[orientation=vertical]:h-full data-[orientation=vertical]:w-px 3xl:flex hidden">
                </div>
                <button data-slot="button"
                    class="items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-all disabled:pointer-events-none disabled:opacity-50 [&amp;_svg]:pointer-events-none [&amp;_svg:not([class*='size-'])]:size-4 shrink-0 [&amp;_svg]:shrink-0 outline-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive hover:bg-accent hover:text-accent-foreground dark:hover:bg-accent/50 size-8 3xl:flex hidden"
                    title="Toggle layout" onclick="toggleLayout(event)">
                    <span class="sr-only">Toggle layout</span>
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none"
                        stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"
                        class="lucide lucide-gallery-horizontal">
                        <path d="M2 3v18"></path>
                        <rect width="12" height="18" x="6" y="3" rx="2"></rect>
                        <path d="M22 3v18"></path>
                    </svg>
                </button>
                <div data-orientation="vertical" role="none" data-slot="separator"
                    class="bg-border shrink-0 data-[orientation=horizontal]:h-px data-[orientation=horizontal]:w-full data-[orientation=vertical]:h-full data-[orientation=vertical]:w-px">
                </div>
                <button data-slot="button"
                    class="inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-all disabled:pointer-events-none disabled:opacity-50 [&amp;_svg]:pointer-events-none [&amp;_svg:not([class*='size-'])]:size-4 shrink-0 [&amp;_svg]:shrink-0 outline-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive hover:bg-accent hover:text-accent-foreground dark:hover:bg-accent/50 group/toggle extend-touch-target size-8"
                    title="Toggle theme" onclick="onThemeSwitch(event)">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none"
                        stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"
                        class="size-4.5">
                        <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
                        <path d="M12 12m-9 0a9 9 0 1 0 18 0a9 9 0 1 0 -18 0"></path>
                        <path d="M12 3l0 18"></path>
                        <path d="M12 9l4.65 -4.65"></path>
                        <path d="M12 14.3l7.37 -7.37"></path>
                        <path d="M12 19.6l8.85 -8.85"></path>
                    </svg>
                    <span class="sr-only">Toggle theme</span>
                </button>
            </div>
        </div>
    </div>
</header>
        <main class="flex flex-1 flex-col">
            <div class="container-wrapper flex flex-1 flex-col px-2">
                <div data-slot="sidebar-wrapper" style="--sidebar-width: 16rem; --sidebar-width-icon: 3rem;"
                    class="group/sidebar-wrapper has-data-[variant=inset]:bg-sidebar flex w-full 3xl:fixed:container 3xl:fixed:px-3 min-h-min flex-1 items-start px-0 [--sidebar-width:220px] [--top-spacing:0] lg:grid lg:grid-cols-[var(--sidebar-width)_minmax(0,1fr)] lg:[--sidebar-width:240px] lg:[--top-spacing:calc(var(--spacing)*4)]">
                    <div data-slot="sidebar"
                        class="text-sidebar-foreground w-(--sidebar-width) flex-col sticky top-[calc(var(--header-height)+1px)] z-30 hidden h-[calc(100svh-var(--header-height)-var(--footer-height))] bg-transparent lg:flex">
                        <div data-slot="sidebar-content" data-sidebar="content"
                            class="flex min-h-0 flex-1 flex-col gap-2 overflow-auto group-data-[collapsible=icon]:overflow-hidden no-scrollbar px-2 pb-12">
                            <div class="h-(--top-spacing) shrink-0"></div>
                            <div view-transition-name="sidebar" data-slot="sidebar-group" data-sidebar="group"
    class="relative flex w-full min-w-0 flex-col p-2 no-scrollbar">
    

    
    
    

    

    
    

    
    <div data-slot="sidebar-group" data-sidebar="group" class="relative flex w-full min-w-0 flex-col p-2">
        <div data-slot="sidebar-group-content" data-sidebar="group-content" class="w-full text-sm">
            <ul data-slot="sidebar-menu" data-sidebar="menu" class="flex w-full min-w-0 flex-col gap-0.5">
                
                
                <li data-slot="sidebar-menu-item" data-sidebar="menu-item" class="group/menu-item relative">
    <a data-slot="sidebar-menu-button" data-active="false" data-sidebar="menu-button"
        data-size="default" href="/acvr/"
        class="hover:bg-sidebar-accent hover:text-sidebar-accent-foreground peer/menu-button flex items-center gap-2 rounded-md p-2 text-left outline-hidden ring-sidebar-ring transition-[width,height,padding] focus-visible:ring-2 active:bg-sidebar-accent active:text-sidebar-accent-foreground disabled:pointer-events-none disabled:opacity-50 group-has-data-[sidebar=menu-action]/menu-item:pr-8 aria-disabled:pointer-events-none aria-disabled:opacity-50 data-[active=true]:font-medium data-[active=true]:text-sidebar-accent-foreground data-[state=open]:hover:bg-sidebar-accent data-[state=open]:hover:text-sidebar-accent-foreground group-data-[collapsible=icon]:size-8! group-data-[collapsible=icon]:p-2! [&>span:last-child]:truncate [&>svg]:size-4 [&>svg]:shrink-0 data-[active=true]:bg-accent data-[active=true]:border-accent 3xl:fixed:w-full 3xl:fixed:max-w-48 relative h-[30px] w-fit overflow-visible border border-transparent text-[0.8rem] font-medium after:absolute after:inset-x-0 after:-inset-y-1 after:z-0 after:rounded-md">

        
        Home
        

        

        

        
    </a>
</li>
                
                
                
                <li data-slot="sidebar-menu-item" data-sidebar="menu-item" class="group/menu-item relative">
    <a data-slot="sidebar-menu-button" data-active="false" data-sidebar="menu-button"
        data-size="default" href="/acvr/usage/"
        class="hover:bg-sidebar-accent hover:text-sidebar-accent-foreground peer/menu-button flex items-center gap-2 rounded-md p-2 text-left outline-hidden ring-sidebar-ring transition-[width,height,padding] focus-visible:ring-2 active:bg-sidebar-accent active:text-sidebar-accent-foreground disabled:pointer-events-none disabled:opacity-50 group-has-data-[sidebar=menu-action]/menu-item:pr-8 aria-disabled:pointer-events-none aria-disabled:opacity-50 data-[active=true]:font-medium data-[active=true]:text-sidebar-accent-foreground data-[state=open]:hover:bg-sidebar-accent data-[state=open]:hover:text-sidebar-accent-foreground group-data-[collapsible=icon]:size-8! group-data-[collapsible=icon]:p-2! [&>span:last-child]:truncate [&>svg]:size-4 [&>svg]:shrink-0 data-[active=true]:bg-accent data-[active=true]:border-accent 3xl:fixed:w-full 3xl:fixed:max-w-48 relative h-[30px] w-fit overflow-visible border border-transparent text-[0.8rem] font-medium after:absolute after:inset-x-0 after:-inset-y-1 after:z-0 after:rounded-md">

        
        Usage
        

        

        

        
    </a>
</li>
                
                
                
                <li data-slot="sidebar-menu-item" data-sidebar="menu-item" class="group/menu-item relative">
    <a data-slot="sidebar-menu-button" data-active="false" data-sidebar="menu-button"
        data-size="default" href="/acvr/indexing/"
        class="hover:bg-sidebar-accent hover:text-sidebar-accent-foreground peer/menu-button flex items-center gap-2 rounded-md p-2 text-left outline-hidden ring-sidebar-ring transition-[width,height,padding] focus-visible:ring-2 active:bg-sidebar-accent active:text-sidebar-accent-foreground disabled:pointer-events-none disabled:opacity-50 group-has-data-[sidebar=menu-action]/menu-item:pr-8 aria-disabled:pointer-events-none aria-disabled:opacity-50 data-[active=true]:font-medium data-[active=true]:text-sidebar-accent-foreground data-[state=open]:hover:bg-sidebar-accent data-[state=open]:hover:text-sidebar-accent-foreground group-data-[collapsible=icon]:size-8! group-data-[collapsible=icon]:p-2! [&>span:last-child]:truncate [&>svg]:size-4 [&>svg]:shrink-0 data-[active=true]:bg-accent data-[active=true]:border-accent 3xl:fixed:w-full 3xl:fixed:max-w-48 relative h-[30px] w-fit overflow-visible border border-transparent text-[0.8rem] font-medium after:absolute after:inset-x-0 after:-inset-y-1 after:z-0 after:rounded-md">

        
        Indexing & Modes
        

        

        

        
    </a>
</li>
                
                
                
                <li data-slot="sidebar-menu-item" data-sidebar="menu-item" class="group/menu-item relative">
    <a data-slot="sidebar-menu-button" data-active="false" data-sidebar="menu-button"
        data-size="default" href="/acvr/technical/"
        class="hover:bg-sidebar-accent hover:text-sidebar-accent-foreground peer/menu-button flex items-center gap-2 rounded-md p-2 text-left outline-hidden ring-sidebar-ring transition-[width,height,padding] focus-visible:ring-2 active:bg-sidebar-accent active:text-sidebar-accent-foreground disabled:pointer-events-none disabled:opacity-50 group-has-data-[sidebar=menu-action]/menu-item:pr-8 aria-disabled:pointer-events-none aria-disabled:opacity-50 data-[active=true]:font-medium data-[active=true]:text-sidebar-accent-foreground data-[state=open]:hover:bg-sidebar-accent data-[state=open]:hover:text-sidebar-accent-foreground group-data-[collapsible=icon]:size-8! group-data-[collapsible=icon]:p-2! [&>span:last-child]:truncate [&>svg]:size-4 [&>svg]:shrink-0 data-[active=true]:bg-accent data-[active=true]:border-accent 3xl:fixed:w-full 3xl:fixed:max-w-48 relative h-[30px] w-fit overflow-visible border border-transparent text-[0.8rem] font-medium after:absolute after:inset-x-0 after:-inset-y-1 after:z-0 after:rounded-md">

        
        Technical
        

        

        

        
    </a>
</li>
                
                
                
                <li data-slot="sidebar-menu-item" data-sidebar="menu-item" class="group/menu-item relative">
    <a data-slot="sidebar-menu-button" data-active="false" data-sidebar="menu-button"
        data-size="default" href="/acvr/benchmark/"
        class="hover:bg-sidebar-accent hover:text-sidebar-accent-foreground peer/menu-button flex items-center gap-2 rounded-md p-2 text-left outline-hidden ring-sidebar-ring transition-[width,height,padding] focus-visible:ring-2 active:bg-sidebar-accent active:text-sidebar-accent-foreground disabled:pointer-events-none disabled:opacity-50 group-has-data-[sidebar=menu-action]/menu-item:pr-8 aria-disabled:pointer-events-none aria-disabled:opacity-50 data-[active=true]:font-medium data-[active=true]:text-sidebar-accent-foreground data-[state=open]:hover:bg-sidebar-accent data-[state=open]:hover:text-sidebar-accent-foreground group-data-[collapsible=icon]:size-8! group-data-[collapsible=icon]:p-2! [&>span:last-child]:truncate [&>svg]:size-4 [&>svg]:shrink-0 data-[active=true]:bg-accent data-[active=true]:border-accent 3xl:fixed:w-full 3xl:fixed:max-w-48 relative h-[30px] w-fit overflow-visible border border-transparent text-[0.8rem] font-medium after:absolute after:inset-x-0 after:-inset-y-1 after:z-0 after:rounded-md">

        
        Benchmarking
        

        

        

        
    </a>
</li>
                
                
                
                <li data-slot="sidebar-menu-item" data-sidebar="menu-item" class="group/menu-item relative">
    <a data-slot="sidebar-menu-button" data-active="true" data-sidebar="menu-button"
        data-size="default" href="/acvr/api/"
        class="hover:bg-sidebar-accent hover:text-sidebar-accent-foreground peer/menu-button flex items-center gap-2 rounded-md p-2 text-left outline-hidden ring-sidebar-ring transition-[width,height,padding] focus-visible:ring-2 active:bg-sidebar-accent active:text-sidebar-accent-foreground disabled:pointer-events-none disabled:opacity-50 group-has-data-[sidebar=menu-action]/menu-item:pr-8 aria-disabled:pointer-events-none aria-disabled:opacity-50 data-[active=true]:font-medium data-[active=true]:text-sidebar-accent-foreground data-[state=open]:hover:bg-sidebar-accent data-[state=open]:hover:text-sidebar-accent-foreground group-data-[collapsible=icon]:size-8! group-data-[collapsible=icon]:p-2! [&>span:last-child]:truncate [&>svg]:size-4 [&>svg]:shrink-0 data-[active=true]:bg-accent data-[active=true]:border-accent 3xl:fixed:w-full 3xl:fixed:max-w-48 relative h-[30px] w-fit overflow-visible border border-transparent text-[0.8rem] font-medium after:absolute after:inset-x-0 after:-inset-y-1 after:z-0 after:rounded-md">

        
        API
        

        

        

        
    </a>
</li>
                
                
            </ul>
        </div>
    </div>
    

    


    
</div>
                        </div>
                    </div>
                    <div class="h-full w-full">
                        <div data-slot="docs" class="flex items-stretch text-[1.05rem] sm:text-[15px] xl:w-full">
                            <div class="flex min-w-0 flex-1 flex-col">
                                <div class="h-(--top-spacing) shrink-0"></div>
                                <article class="w-full" view-transition-name="page">
  <div class="flex flex-col gap-2">
    <div class="flex flex-col gap-2">
      <div id="page-header" class="flex items-start justify-between">
        <h1
          class="scroll-m-20 text-4xl font-semibold tracking-tight sm:text-3xl xl:text-4xl"
        >
          API
        </h1>

        <div class="flex items-center gap-2 pt-1.5">
          
<button onclick="fetch(`https://janclemenslab.org/acvr/api.md`).then((r) => r.blob()).then((blob) => navigator.clipboard.write([new ClipboardItem({ 'text/plain': blob })]))" 
        data-slot="button" 
        class="cursor-pointer inline-flex items-center justify-center whitespace-nowrap text-sm font-medium transition-all disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg:not([class*='size-'])]:size-4 shrink-0 [&_svg]:shrink-0 outline-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive bg-secondary text-secondary-foreground hover:bg-secondary/80 rounded-md gap-1.5 px-3 has-[&>svg]:px-2.5 h-8 shadow-none md:h-7 md:text-[0.8rem]">
<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="tabler-icon tabler-icon-copy ">
    <path d="M7 7m0 2.667a2.667 2.667 0 0 1 2.667 -2.667h8.666a2.667 2.667 0 0 1 2.667 2.667v8.666a2.667 2.667 0 0 1 -2.667 2.667h-8.666a2.667 2.667 0 0 1 -2.667 -2.667z"></path><path d="M4.012 16.737a2.005 2.005 0 0 1 -1.012 -1.737v-10c0 -1.1 .9 -2 2 -2h10c.75 0 1.158 .385 1.5 1"></path>
</svg>
<span class="max-md:hidden">Copy Page</span>
</button> 
          
          <a
            data-slot="button"
            id="previous-button"
            class="inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-all disabled:pointer-events-none disabled:opacity-50 [&amp;_svg]:pointer-events-none [&amp;_svg:not([class*='size-'])]:size-4 shrink-0 [&amp;_svg]:shrink-0 outline-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive bg-secondary text-secondary-foreground hover:bg-secondary/80 extend-touch-target size-8 shadow-none md:size-7"
            href="/acvr/benchmark/"
          >
            <svg
              xmlns="http://www.w3.org/2000/svg"
              width="24"
              height="24"
              viewBox="0 0 24 24"
              fill="none"
              stroke="currentColor"
              stroke-width="2"
              stroke-linecap="round"
              stroke-linejoin="round"
              class="tabler-icon tabler-icon-arrow-left"
            >
              <path d="M5 12l14 0"></path>
              <path d="M5 12l6 6"></path>
              <path d="M5 12l6 -6"></path>
            </svg>
            <span class="sr-only">Previous</span>
          </a>
           
          
        </div>
      </div>
      
    </div>
    <div class="flex justify-end items-center">
       
    </div>
  </div>
  <div class="typography w-full flex-1 *:data-[slot=alert]:first:mt-0">
    <h2 id="videoreader"><code>VideoReader</code></h2>


<div class="doc doc-object doc-class">



<a id="acvr.reader.VideoReader"></a>
    <div class="doc doc-contents first">



        <p>High-level video reader with array-style access.</p>








              <details class="mkdocstrings-source">
                <summary>Source code in <code>acvr/reader.py</code></summary>
                <pre class="codehilite"><code class="language-python">class VideoReader:
    """High-level video reader with array-style access."""

    def __init__(
        self,
        path: str,
        video_stream_index: int = 0,
        *,
        build_index: bool = True,
        decoded_frame_cache_size: int = 0,
        scrub_bucket_ms: int = 25,
        scrub_bucket_lru_size: int = 4096,
        threading: bool = True,
        thread_count: int = 0,
        index_policy: str = "decode",
    ) -&gt; None:
        """Create a reader for the given video path.

        Args:
            path: Path to the video file to open.
            video_stream_index: Video stream index to decode.
            build_index: Whether to build a keyframe index on initialization (default
                True); can speed up accurate random seeks but adds upfront cost.
                speed up accurate random seeks but adds upfront cost.
            decoded_frame_cache_size: Number of decoded frames to keep in an
                in-memory LRU cache; helpful for repeated access to nearby frames.
            scrub_bucket_ms: Bucket size (milliseconds) used to group timestamps
                for fast scrub queries.
            scrub_bucket_lru_size: LRU size for the scrub bucket cache.
            threading: Whether to enable threaded decoding in the backend.
            thread_count: Number of decoding threads (0 lets backend decide).
            index_policy: Indexing policy, either ``"decode"`` for decode-order
                frames or ``"timeline"`` for timestamp-based access.

        Raises:
            ValueError: If ``index_policy`` is not ``"decode"`` or ``"timeline"``.
        """

        self._backend = PyAVVideoBackend(
            path,
            video_stream_index=video_stream_index,
            build_index=build_index,
            decoded_frame_cache_size=decoded_frame_cache_size,
            scrub_bucket_ms=scrub_bucket_ms,
            scrub_bucket_lru_size=scrub_bucket_lru_size,
            threading=threading,
            thread_count=thread_count,
        )
        if index_policy not in {"decode", "timeline"}:
            raise ValueError("index_policy must be 'decode' or 'timeline'")
        self._index_policy = index_policy

    def close(self) -&gt; None:
        """Close the underlying video resources."""

        self._backend.close()

    def __enter__(self) -&gt; "VideoReader":
        """Return self for context manager usage."""

        return self

    def __exit__(self, exc_type, exc, tb) -&gt; None:
        """Close the reader when leaving a context manager.

        Args:
            exc_type: Exception type, if any.
            exc: Exception instance, if any.
            tb: Traceback, if any.
        """

        self.close()

    def __len__(self) -&gt; int:
        """Return the number of frames in the video."""

        return self.number_of_frames

    def __getitem__(self, key: IndexKey) -&gt; Union[np.ndarray, List[np.ndarray]]:
        """Return a frame or list of frames for the given index or slice.

        Indexing semantics are controlled by `index_policy`:
        - 'decode' (default): index refers to decode-order frame number.
        - 'timeline': index is mapped to timestamp using nominal FPS, and an accurate
          timestamp seek is performed.

        Args:
            key: Frame index or slice to retrieve.

        Returns:
            A single frame array or list of frame arrays.
        """

        if isinstance(key, slice):
            start, stop, step = key.indices(self.number_of_frames)
            return [self[i] for i in range(start, stop, step)]

        i = int(key)
        if self._index_policy == "decode":
            return self._backend.frame_at_index(i)
        # timeline policy
        fps = self.nominal_frame_rate or self.frame_rate or 1.0
        t_s = float(i) / fps
        return self._backend.read_frame_at(t_s).image

    def __iter__(self) -&gt; Iterator[np.ndarray]:
        """Iterate over all frames in the video."""

        return self.iter_frames()

    @property
    def frame_height(self) -&gt; int:
        """Return the frame height in pixels."""

        return self._backend.frame_height

    @property
    def frame_width(self) -&gt; int:
        """Return the frame width in pixels."""

        return self._backend.frame_width

    @property
    def frame_rate(self) -&gt; float:
        """Return the video frame rate."""

        return self._backend.frame_rate

    @property
    def nominal_frame_rate(self) -&gt; float:
        """Return the nominal video frame rate (guessed_rate when available)."""

        return self._backend.nominal_frame_rate

    @property
    def fourcc(self) -&gt; int:
        """Return the fourcc codec identifier."""

        return self._backend.fourcc

    @property
    def frame_format(self) -&gt; int:
        """Return the pixel format identifier."""

        return self._backend.frame_format

    @property
    def number_of_frames(self) -&gt; int:
        """Return the total number of frames."""

        return self._backend.number_of_frames

    @property
    def frame_shape(self) -&gt; tuple:
        """Return the expected frame shape (H, W, C)."""

        return self._backend.frame_shape

    @property
    def current_frame_pos(self) -&gt; float:
        """Return the last accessed frame index."""

        return self._backend.current_frame_pos

    def build_keyframe_index(self, *, max_packets: Optional[int] = None) -&gt; List[KeyframeEntry]:
        """Build a keyframe index for faster random access.

        Args:
            max_packets: Optional cap on packets to inspect.

        Returns:
            A list of keyframe entries.
        """

        return self._backend.build_keyframe_index(max_packets=max_packets)

    def read_keyframe_at(
        self,
        t_s: float,
        *,
        mode: str = "nearest",
        decode_rgb: bool = True,
    ) -&gt; DecodedFrame:
        """Return a nearby keyframe for fast scrubbing.

        Args:
            t_s: Timestamp in seconds to seek around.
            mode: Selection mode (``"nearest"``, ``"before"``, or ``"after"``).
            decode_rgb: Whether to decode into RGB arrays.

        Returns:
            The decoded keyframe.
        """

        return self._backend.read_keyframe_at(t_s, mode=mode, decode_rgb=decode_rgb)

    def read_frame_at(
        self,
        t_s: float,
        *,
        return_first_after: bool = True,
        max_decode_frames: int = 10_000,
        use_index: bool = True,
    ) -&gt; DecodedFrame:
        """Return a frame at a timestamp with accurate seeking.

        Args:
            t_s: Timestamp in seconds to seek to.
            return_first_after: Return the first frame after the timestamp.
            max_decode_frames: Cap on frames to decode while seeking.
            use_index: Whether to use the keyframe index if available.

        Returns:
            The decoded frame at the target timestamp.
        """

        return self._backend.read_frame_at(
            t_s,
            return_first_after=return_first_after,
            max_decode_frames=max_decode_frames,
            use_index=use_index,
        )

    def read_frame_fast(
        self,
        *,
        index: Optional[int] = None,
        t_s: Optional[float] = None,
        decode_rgb: bool = True,
        use_sequential: bool = True,
    ) -&gt; DecodedFrame:
        """Return a fast, approximate frame for an index or timestamp.

        Args:
            index: Decode-order frame index to seek to.
            t_s: Timestamp in seconds to seek to.
            decode_rgb: Whether to decode into RGB arrays.
            use_sequential: Allow sequential decoding when available.

        Returns:
            The decoded frame closest to the request.
        """

        return self._backend.read_frame_fast(
            index=index,
            t_s=t_s,
            decode_rgb=decode_rgb,
            use_sequential=use_sequential,
        )

    def read_next(self, *, decode_rgb: bool = True) -&gt; np.ndarray:
        """Return the next frame using sequential decoding.

        Args:
            decode_rgb: Whether to decode into RGB arrays.

        Returns:
            The next decoded frame image.
        """

        return self._backend.read_next_frame(decode_rgb=decode_rgb).image

    def iter_frames(self, *, decode_rgb: bool = True) -&gt; Iterator[np.ndarray]:
        """Iterate frames sequentially without seeking."""

        for frame in self._backend.iter_frames(decode_rgb=decode_rgb):
            yield frame.image

    # Public PTS/time helpers
    def pts_at_index(self, index: int) -&gt; Optional[int]:
        """Return the PTS for a given frame index."""

        return self._backend.pts_at_index(int(index))

    def time_at_index(self, index: int) -&gt; float:
        """Return the timestamp (seconds) for a given frame index."""

        return self._backend.time_at_index(int(index))

    def index_from_pts(self, pts: int) -&gt; int:
        """Return the nearest frame index for a PTS value."""

        return self._backend.index_from_pts(int(pts))

    def index_from_time(self, t_s: float) -&gt; int:
        """Return the nearest frame index for a timestamp in seconds."""

        return self._backend.index_from_time(float(t_s))

    def read_frame(
        self,
        *,
        index: Optional[int] = None,
        t_s: Optional[float] = None,
        mode: str = "accurate",
        decode_rgb: bool = True,
        keyframe_mode: str = "nearest",
        use_sequential: bool = True,
    ) -&gt; DecodedFrame:
        """Read a frame using a selectable access mode."""

        return self._backend.read_frame(
            index=index,
            t_s=t_s,
            mode=mode,
            decode_rgb=decode_rgb,
            keyframe_mode=keyframe_mode,
            use_sequential=use_sequential,
        )</code></pre>
              </details>



<div class="doc doc-children">







<div class="doc doc-object doc-attribute">



<h2 id="acvr.reader.VideoReader._backend" class="doc doc-heading">
            <code class=" language-python">_backend = PyAVVideoBackend(path, video_stream_index=video_stream_index, build_index=build_index, decoded_frame_cache_size=decoded_frame_cache_size, scrub_bucket_ms=scrub_bucket_ms, scrub_bucket_lru_size=scrub_bucket_lru_size, threading=threading, thread_count=thread_count)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h2>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h2 id="acvr.reader.VideoReader._index_policy" class="doc doc-heading">
            <code class=" language-python">_index_policy = index_policy</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h2>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h2 id="acvr.reader.VideoReader.current_frame_pos" class="doc doc-heading">
            <code class=" language-python">current_frame_pos</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h2>


    <div class="doc doc-contents ">

        <p>Return the last accessed frame index.</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h2 id="acvr.reader.VideoReader.fourcc" class="doc doc-heading">
            <code class=" language-python">fourcc</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h2>


    <div class="doc doc-contents ">

        <p>Return the fourcc codec identifier.</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h2 id="acvr.reader.VideoReader.frame_format" class="doc doc-heading">
            <code class=" language-python">frame_format</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h2>


    <div class="doc doc-contents ">

        <p>Return the pixel format identifier.</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h2 id="acvr.reader.VideoReader.frame_height" class="doc doc-heading">
            <code class=" language-python">frame_height</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h2>


    <div class="doc doc-contents ">

        <p>Return the frame height in pixels.</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h2 id="acvr.reader.VideoReader.frame_rate" class="doc doc-heading">
            <code class=" language-python">frame_rate</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h2>


    <div class="doc doc-contents ">

        <p>Return the video frame rate.</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h2 id="acvr.reader.VideoReader.frame_shape" class="doc doc-heading">
            <code class=" language-python">frame_shape</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h2>


    <div class="doc doc-contents ">

        <p>Return the expected frame shape (H, W, C).</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h2 id="acvr.reader.VideoReader.frame_width" class="doc doc-heading">
            <code class=" language-python">frame_width</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h2>


    <div class="doc doc-contents ">

        <p>Return the frame width in pixels.</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h2 id="acvr.reader.VideoReader.nominal_frame_rate" class="doc doc-heading">
            <code class=" language-python">nominal_frame_rate</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h2>


    <div class="doc doc-contents ">

        <p>Return the nominal video frame rate (guessed_rate when available).</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h2 id="acvr.reader.VideoReader.number_of_frames" class="doc doc-heading">
            <code class=" language-python">number_of_frames</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h2>


    <div class="doc doc-contents ">

        <p>Return the total number of frames.</p>

    </div>

</div>




<div class="doc doc-object doc-function">


<h2 id="acvr.reader.VideoReader.__enter__" class="doc doc-heading">
            <code class=" language-python">__enter__()</code>

</h2>


    <div class="doc doc-contents ">

        <p>Return self for context manager usage.</p>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>acvr/reader.py</code></summary>
              <pre class="codehilite"><code class="language-python">def __enter__(self) -&gt; "VideoReader":
    """Return self for context manager usage."""

    return self</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="acvr.reader.VideoReader.__exit__" class="doc doc-heading">
            <code class=" language-python">__exit__(exc_type, exc, tb)</code>

</h2>


    <div class="doc doc-contents ">

        <p>Close the reader when leaving a context manager.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <div class="table-wrapper"><table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>exc_type</code>
            </td>
            <td>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Exception type, if any.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>exc</code>
            </td>
            <td>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Exception instance, if any.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>tb</code>
            </td>
            <td>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Traceback, if any.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
      </tbody>
    </table></div>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>acvr/reader.py</code></summary>
              <pre class="codehilite"><code class="language-python">def __exit__(self, exc_type, exc, tb) -&gt; None:
    """Close the reader when leaving a context manager.

    Args:
        exc_type: Exception type, if any.
        exc: Exception instance, if any.
        tb: Traceback, if any.
    """

    self.close()</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="acvr.reader.VideoReader.__getitem__" class="doc doc-heading">
            <code class=" language-python">__getitem__(key)</code>

</h2>


    <div class="doc doc-contents ">

        <p>Return a frame or list of frames for the given index or slice.</p>
<p>Indexing semantics are controlled by <code>index_policy</code>:
- 'decode' (default): index refers to decode-order frame number.
- 'timeline': index is mapped to timestamp using nominal FPS, and an accurate
  timestamp seek is performed.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <div class="table-wrapper"><table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>key</code>
            </td>
            <td>
                  <code><span title="acvr.reader.IndexKey">IndexKey</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Frame index or slice to retrieve.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
      </tbody>
    </table></div>


    <p><span class="doc-section-title">Returns:</span></p>
    <div class="table-wrapper"><table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code><span title="typing.Union">Union</span>[<span title="numpy.ndarray">ndarray</span>, <span title="typing.List">List</span>[<span title="numpy.ndarray">ndarray</span>]]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>A single frame array or list of frame arrays.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table></div>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>acvr/reader.py</code></summary>
              <pre class="codehilite"><code class="language-python">def __getitem__(self, key: IndexKey) -&gt; Union[np.ndarray, List[np.ndarray]]:
    """Return a frame or list of frames for the given index or slice.

    Indexing semantics are controlled by `index_policy`:
    - 'decode' (default): index refers to decode-order frame number.
    - 'timeline': index is mapped to timestamp using nominal FPS, and an accurate
      timestamp seek is performed.

    Args:
        key: Frame index or slice to retrieve.

    Returns:
        A single frame array or list of frame arrays.
    """

    if isinstance(key, slice):
        start, stop, step = key.indices(self.number_of_frames)
        return [self[i] for i in range(start, stop, step)]

    i = int(key)
    if self._index_policy == "decode":
        return self._backend.frame_at_index(i)
    # timeline policy
    fps = self.nominal_frame_rate or self.frame_rate or 1.0
    t_s = float(i) / fps
    return self._backend.read_frame_at(t_s).image</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="acvr.reader.VideoReader.__init__" class="doc doc-heading">
            <code class=" language-python">__init__(path, video_stream_index=0, *, build_index=True, decoded_frame_cache_size=0, scrub_bucket_ms=25, scrub_bucket_lru_size=4096, threading=True, thread_count=0, index_policy='decode')</code>

</h2>


    <div class="doc doc-contents ">

        <p>Create a reader for the given video path.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <div class="table-wrapper"><table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>path</code>
            </td>
            <td>
                  <code><span title="str">str</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Path to the video file to open.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>video_stream_index</code>
            </td>
            <td>
                  <code><span title="int">int</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Video stream index to decode.</p>
              </div>
            </td>
            <td>
                  <code>0</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>build_index</code>
            </td>
            <td>
                  <code><span title="bool">bool</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Whether to build a keyframe index on initialization (default
True); can speed up accurate random seeks but adds upfront cost.
speed up accurate random seeks but adds upfront cost.</p>
              </div>
            </td>
            <td>
                  <code>True</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>decoded_frame_cache_size</code>
            </td>
            <td>
                  <code><span title="int">int</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Number of decoded frames to keep in an
in-memory LRU cache; helpful for repeated access to nearby frames.</p>
              </div>
            </td>
            <td>
                  <code>0</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>scrub_bucket_ms</code>
            </td>
            <td>
                  <code><span title="int">int</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Bucket size (milliseconds) used to group timestamps
for fast scrub queries.</p>
              </div>
            </td>
            <td>
                  <code>25</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>scrub_bucket_lru_size</code>
            </td>
            <td>
                  <code><span title="int">int</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>LRU size for the scrub bucket cache.</p>
              </div>
            </td>
            <td>
                  <code>4096</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>threading</code>
            </td>
            <td>
                  <code><span title="bool">bool</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Whether to enable threaded decoding in the backend.</p>
              </div>
            </td>
            <td>
                  <code>True</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>thread_count</code>
            </td>
            <td>
                  <code><span title="int">int</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Number of decoding threads (0 lets backend decide).</p>
              </div>
            </td>
            <td>
                  <code>0</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>index_policy</code>
            </td>
            <td>
                  <code><span title="str">str</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Indexing policy, either <code>"decode"</code> for decode-order
frames or <code>"timeline"</code> for timestamp-based access.</p>
              </div>
            </td>
            <td>
                  <code>&#39;decode&#39;</code>
            </td>
          </tr>
      </tbody>
    </table></div>


<p><span class="doc-section-title">Raises:</span></p>
    <div class="table-wrapper"><table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code><span title="ValueError">ValueError</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If <code>index_policy</code> is not <code>"decode"</code> or <code>"timeline"</code>.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table></div>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>acvr/reader.py</code></summary>
              <pre class="codehilite"><code class="language-python">def __init__(
    self,
    path: str,
    video_stream_index: int = 0,
    *,
    build_index: bool = True,
    decoded_frame_cache_size: int = 0,
    scrub_bucket_ms: int = 25,
    scrub_bucket_lru_size: int = 4096,
    threading: bool = True,
    thread_count: int = 0,
    index_policy: str = "decode",
) -&gt; None:
    """Create a reader for the given video path.

    Args:
        path: Path to the video file to open.
        video_stream_index: Video stream index to decode.
        build_index: Whether to build a keyframe index on initialization (default
            True); can speed up accurate random seeks but adds upfront cost.
            speed up accurate random seeks but adds upfront cost.
        decoded_frame_cache_size: Number of decoded frames to keep in an
            in-memory LRU cache; helpful for repeated access to nearby frames.
        scrub_bucket_ms: Bucket size (milliseconds) used to group timestamps
            for fast scrub queries.
        scrub_bucket_lru_size: LRU size for the scrub bucket cache.
        threading: Whether to enable threaded decoding in the backend.
        thread_count: Number of decoding threads (0 lets backend decide).
        index_policy: Indexing policy, either ``"decode"`` for decode-order
            frames or ``"timeline"`` for timestamp-based access.

    Raises:
        ValueError: If ``index_policy`` is not ``"decode"`` or ``"timeline"``.
    """

    self._backend = PyAVVideoBackend(
        path,
        video_stream_index=video_stream_index,
        build_index=build_index,
        decoded_frame_cache_size=decoded_frame_cache_size,
        scrub_bucket_ms=scrub_bucket_ms,
        scrub_bucket_lru_size=scrub_bucket_lru_size,
        threading=threading,
        thread_count=thread_count,
    )
    if index_policy not in {"decode", "timeline"}:
        raise ValueError("index_policy must be 'decode' or 'timeline'")
    self._index_policy = index_policy</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="acvr.reader.VideoReader.__iter__" class="doc doc-heading">
            <code class=" language-python">__iter__()</code>

</h2>


    <div class="doc doc-contents ">

        <p>Iterate over all frames in the video.</p>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>acvr/reader.py</code></summary>
              <pre class="codehilite"><code class="language-python">def __iter__(self) -&gt; Iterator[np.ndarray]:
    """Iterate over all frames in the video."""

    return self.iter_frames()</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="acvr.reader.VideoReader.__len__" class="doc doc-heading">
            <code class=" language-python">__len__()</code>

</h2>


    <div class="doc doc-contents ">

        <p>Return the number of frames in the video.</p>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>acvr/reader.py</code></summary>
              <pre class="codehilite"><code class="language-python">def __len__(self) -&gt; int:
    """Return the number of frames in the video."""

    return self.number_of_frames</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="acvr.reader.VideoReader.build_keyframe_index" class="doc doc-heading">
            <code class=" language-python">build_keyframe_index(*, max_packets=None)</code>

</h2>


    <div class="doc doc-contents ">

        <p>Build a keyframe index for faster random access.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <div class="table-wrapper"><table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>max_packets</code>
            </td>
            <td>
                  <code><span title="typing.Optional">Optional</span>[<span title="int">int</span>]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Optional cap on packets to inspect.</p>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
      </tbody>
    </table></div>


    <p><span class="doc-section-title">Returns:</span></p>
    <div class="table-wrapper"><table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code><span title="typing.List">List</span>[<span title="acvr._pyav_backend.KeyframeEntry">KeyframeEntry</span>]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>A list of keyframe entries.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table></div>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>acvr/reader.py</code></summary>
              <pre class="codehilite"><code class="language-python">def build_keyframe_index(self, *, max_packets: Optional[int] = None) -&gt; List[KeyframeEntry]:
    """Build a keyframe index for faster random access.

    Args:
        max_packets: Optional cap on packets to inspect.

    Returns:
        A list of keyframe entries.
    """

    return self._backend.build_keyframe_index(max_packets=max_packets)</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="acvr.reader.VideoReader.close" class="doc doc-heading">
            <code class=" language-python">close()</code>

</h2>


    <div class="doc doc-contents ">

        <p>Close the underlying video resources.</p>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>acvr/reader.py</code></summary>
              <pre class="codehilite"><code class="language-python">def close(self) -&gt; None:
    """Close the underlying video resources."""

    self._backend.close()</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="acvr.reader.VideoReader.index_from_pts" class="doc doc-heading">
            <code class=" language-python">index_from_pts(pts)</code>

</h2>


    <div class="doc doc-contents ">

        <p>Return the nearest frame index for a PTS value.</p>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>acvr/reader.py</code></summary>
              <pre class="codehilite"><code class="language-python">def index_from_pts(self, pts: int) -&gt; int:
    """Return the nearest frame index for a PTS value."""

    return self._backend.index_from_pts(int(pts))</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="acvr.reader.VideoReader.index_from_time" class="doc doc-heading">
            <code class=" language-python">index_from_time(t_s)</code>

</h2>


    <div class="doc doc-contents ">

        <p>Return the nearest frame index for a timestamp in seconds.</p>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>acvr/reader.py</code></summary>
              <pre class="codehilite"><code class="language-python">def index_from_time(self, t_s: float) -&gt; int:
    """Return the nearest frame index for a timestamp in seconds."""

    return self._backend.index_from_time(float(t_s))</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="acvr.reader.VideoReader.iter_frames" class="doc doc-heading">
            <code class=" language-python">iter_frames(*, decode_rgb=True)</code>

</h2>


    <div class="doc doc-contents ">

        <p>Iterate frames sequentially without seeking.</p>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>acvr/reader.py</code></summary>
              <pre class="codehilite"><code class="language-python">def iter_frames(self, *, decode_rgb: bool = True) -&gt; Iterator[np.ndarray]:
    """Iterate frames sequentially without seeking."""

    for frame in self._backend.iter_frames(decode_rgb=decode_rgb):
        yield frame.image</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="acvr.reader.VideoReader.pts_at_index" class="doc doc-heading">
            <code class=" language-python">pts_at_index(index)</code>

</h2>


    <div class="doc doc-contents ">

        <p>Return the PTS for a given frame index.</p>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>acvr/reader.py</code></summary>
              <pre class="codehilite"><code class="language-python">def pts_at_index(self, index: int) -&gt; Optional[int]:
    """Return the PTS for a given frame index."""

    return self._backend.pts_at_index(int(index))</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="acvr.reader.VideoReader.read_frame" class="doc doc-heading">
            <code class=" language-python">read_frame(*, index=None, t_s=None, mode='accurate', decode_rgb=True, keyframe_mode='nearest', use_sequential=True)</code>

</h2>


    <div class="doc doc-contents ">

        <p>Read a frame using a selectable access mode.</p>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>acvr/reader.py</code></summary>
              <pre class="codehilite"><code class="language-python">def read_frame(
    self,
    *,
    index: Optional[int] = None,
    t_s: Optional[float] = None,
    mode: str = "accurate",
    decode_rgb: bool = True,
    keyframe_mode: str = "nearest",
    use_sequential: bool = True,
) -&gt; DecodedFrame:
    """Read a frame using a selectable access mode."""

    return self._backend.read_frame(
        index=index,
        t_s=t_s,
        mode=mode,
        decode_rgb=decode_rgb,
        keyframe_mode=keyframe_mode,
        use_sequential=use_sequential,
    )</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="acvr.reader.VideoReader.read_frame_at" class="doc doc-heading">
            <code class=" language-python">read_frame_at(t_s, *, return_first_after=True, max_decode_frames=10000, use_index=True)</code>

</h2>


    <div class="doc doc-contents ">

        <p>Return a frame at a timestamp with accurate seeking.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <div class="table-wrapper"><table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>t_s</code>
            </td>
            <td>
                  <code><span title="float">float</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Timestamp in seconds to seek to.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>return_first_after</code>
            </td>
            <td>
                  <code><span title="bool">bool</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Return the first frame after the timestamp.</p>
              </div>
            </td>
            <td>
                  <code>True</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>max_decode_frames</code>
            </td>
            <td>
                  <code><span title="int">int</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Cap on frames to decode while seeking.</p>
              </div>
            </td>
            <td>
                  <code>10000</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>use_index</code>
            </td>
            <td>
                  <code><span title="bool">bool</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Whether to use the keyframe index if available.</p>
              </div>
            </td>
            <td>
                  <code>True</code>
            </td>
          </tr>
      </tbody>
    </table></div>


    <p><span class="doc-section-title">Returns:</span></p>
    <div class="table-wrapper"><table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code><span title="acvr._pyav_backend.DecodedFrame">DecodedFrame</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The decoded frame at the target timestamp.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table></div>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>acvr/reader.py</code></summary>
              <pre class="codehilite"><code class="language-python">def read_frame_at(
    self,
    t_s: float,
    *,
    return_first_after: bool = True,
    max_decode_frames: int = 10_000,
    use_index: bool = True,
) -&gt; DecodedFrame:
    """Return a frame at a timestamp with accurate seeking.

    Args:
        t_s: Timestamp in seconds to seek to.
        return_first_after: Return the first frame after the timestamp.
        max_decode_frames: Cap on frames to decode while seeking.
        use_index: Whether to use the keyframe index if available.

    Returns:
        The decoded frame at the target timestamp.
    """

    return self._backend.read_frame_at(
        t_s,
        return_first_after=return_first_after,
        max_decode_frames=max_decode_frames,
        use_index=use_index,
    )</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="acvr.reader.VideoReader.read_frame_fast" class="doc doc-heading">
            <code class=" language-python">read_frame_fast(*, index=None, t_s=None, decode_rgb=True, use_sequential=True)</code>

</h2>


    <div class="doc doc-contents ">

        <p>Return a fast, approximate frame for an index or timestamp.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <div class="table-wrapper"><table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>index</code>
            </td>
            <td>
                  <code><span title="typing.Optional">Optional</span>[<span title="int">int</span>]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Decode-order frame index to seek to.</p>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>t_s</code>
            </td>
            <td>
                  <code><span title="typing.Optional">Optional</span>[<span title="float">float</span>]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Timestamp in seconds to seek to.</p>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>decode_rgb</code>
            </td>
            <td>
                  <code><span title="bool">bool</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Whether to decode into RGB arrays.</p>
              </div>
            </td>
            <td>
                  <code>True</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>use_sequential</code>
            </td>
            <td>
                  <code><span title="bool">bool</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Allow sequential decoding when available.</p>
              </div>
            </td>
            <td>
                  <code>True</code>
            </td>
          </tr>
      </tbody>
    </table></div>


    <p><span class="doc-section-title">Returns:</span></p>
    <div class="table-wrapper"><table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code><span title="acvr._pyav_backend.DecodedFrame">DecodedFrame</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The decoded frame closest to the request.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table></div>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>acvr/reader.py</code></summary>
              <pre class="codehilite"><code class="language-python">def read_frame_fast(
    self,
    *,
    index: Optional[int] = None,
    t_s: Optional[float] = None,
    decode_rgb: bool = True,
    use_sequential: bool = True,
) -&gt; DecodedFrame:
    """Return a fast, approximate frame for an index or timestamp.

    Args:
        index: Decode-order frame index to seek to.
        t_s: Timestamp in seconds to seek to.
        decode_rgb: Whether to decode into RGB arrays.
        use_sequential: Allow sequential decoding when available.

    Returns:
        The decoded frame closest to the request.
    """

    return self._backend.read_frame_fast(
        index=index,
        t_s=t_s,
        decode_rgb=decode_rgb,
        use_sequential=use_sequential,
    )</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="acvr.reader.VideoReader.read_keyframe_at" class="doc doc-heading">
            <code class=" language-python">read_keyframe_at(t_s, *, mode='nearest', decode_rgb=True)</code>

</h2>


    <div class="doc doc-contents ">

        <p>Return a nearby keyframe for fast scrubbing.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <div class="table-wrapper"><table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>t_s</code>
            </td>
            <td>
                  <code><span title="float">float</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Timestamp in seconds to seek around.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>mode</code>
            </td>
            <td>
                  <code><span title="str">str</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Selection mode (<code>"nearest"</code>, <code>"before"</code>, or <code>"after"</code>).</p>
              </div>
            </td>
            <td>
                  <code>&#39;nearest&#39;</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>decode_rgb</code>
            </td>
            <td>
                  <code><span title="bool">bool</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Whether to decode into RGB arrays.</p>
              </div>
            </td>
            <td>
                  <code>True</code>
            </td>
          </tr>
      </tbody>
    </table></div>


    <p><span class="doc-section-title">Returns:</span></p>
    <div class="table-wrapper"><table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code><span title="acvr._pyav_backend.DecodedFrame">DecodedFrame</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The decoded keyframe.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table></div>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>acvr/reader.py</code></summary>
              <pre class="codehilite"><code class="language-python">def read_keyframe_at(
    self,
    t_s: float,
    *,
    mode: str = "nearest",
    decode_rgb: bool = True,
) -&gt; DecodedFrame:
    """Return a nearby keyframe for fast scrubbing.

    Args:
        t_s: Timestamp in seconds to seek around.
        mode: Selection mode (``"nearest"``, ``"before"``, or ``"after"``).
        decode_rgb: Whether to decode into RGB arrays.

    Returns:
        The decoded keyframe.
    """

    return self._backend.read_keyframe_at(t_s, mode=mode, decode_rgb=decode_rgb)</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="acvr.reader.VideoReader.read_next" class="doc doc-heading">
            <code class=" language-python">read_next(*, decode_rgb=True)</code>

</h2>


    <div class="doc doc-contents ">

        <p>Return the next frame using sequential decoding.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <div class="table-wrapper"><table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>decode_rgb</code>
            </td>
            <td>
                  <code><span title="bool">bool</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Whether to decode into RGB arrays.</p>
              </div>
            </td>
            <td>
                  <code>True</code>
            </td>
          </tr>
      </tbody>
    </table></div>


    <p><span class="doc-section-title">Returns:</span></p>
    <div class="table-wrapper"><table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code><span title="numpy.ndarray">ndarray</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The next decoded frame image.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table></div>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>acvr/reader.py</code></summary>
              <pre class="codehilite"><code class="language-python">def read_next(self, *, decode_rgb: bool = True) -&gt; np.ndarray:
    """Return the next frame using sequential decoding.

    Args:
        decode_rgb: Whether to decode into RGB arrays.

    Returns:
        The next decoded frame image.
    """

    return self._backend.read_next_frame(decode_rgb=decode_rgb).image</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="acvr.reader.VideoReader.time_at_index" class="doc doc-heading">
            <code class=" language-python">time_at_index(index)</code>

</h2>


    <div class="doc doc-contents ">

        <p>Return the timestamp (seconds) for a given frame index.</p>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>acvr/reader.py</code></summary>
              <pre class="codehilite"><code class="language-python">def time_at_index(self, index: int) -&gt; float:
    """Return the timestamp (seconds) for a given frame index."""

    return self._backend.time_at_index(int(index))</code></pre>
            </details>
    </div>

</div>



  </div>

    </div>

</div><h2 id="backend-implementation">Backend implementation</h2>


<div class="doc doc-object doc-class">



<a id="acvr._pyav_backend.PyAVVideoBackend"></a>
    <div class="doc doc-contents first">



        <p>Frame-accurate seeking with keyframe index and scrub acceleration.</p>








              <details class="mkdocstrings-source">
                <summary>Source code in <code>acvr/_pyav_backend.py</code></summary>
                <pre class="codehilite"><code class="language-python">class PyAVVideoBackend:
    """Frame-accurate seeking with keyframe index and scrub acceleration."""

    def __init__(
        self,
        path: str,
        video_stream_index: int = 0,
        *,
        build_index: bool = False,
        decoded_frame_cache_size: int = 0,
        scrub_bucket_ms: int = 25,
        scrub_bucket_lru_size: int = 4096,
        threading: bool = True,
        thread_count: int = 0,
    ) -&gt; None:
        """Initialize the PyAV-backed decoder."""

        self._path = path
        self._container = av.open(path)
        self._stream = self._container.streams.video[video_stream_index]
        self._codec_ctx = self._stream.codec_context
        self._fast_container: Optional[av.container.InputContainer] = None
        self._fast_stream: Optional[av.video.stream.VideoStream] = None
        self._fast_first_frame_number: Optional[int] = None
        self._fast_decoder = None
        self._fast_last_pts: Optional[int] = None
        self._seq_container: Optional[av.container.InputContainer] = None
        self._seq_stream: Optional[av.video.stream.VideoStream] = None
        self._seq_decoder = None
        self._seq_frame_index: int = 0
        self._last_index: Optional[int] = None
        self._last_fast_index: Optional[int] = None

        self._time_base: Fraction = self._stream.time_base
        self._start_pts: int = self._stream.start_time if self._stream.start_time is not None else 0

        self._keyframes: List[KeyframeEntry] = []
        self._index_built: bool = False

        self._frame_pts: Optional[List[int]] = None
        self._frame_count: int = int(self._stream.frames or 0)
        self._current_frame_pos: float = 0.0

        self._frame_cache = _LRU(decoded_frame_cache_size)

        self._scrub_bucket_ms = max(1, int(scrub_bucket_ms))
        self._bucket_to_kfidx = _LRU(scrub_bucket_lru_size)
        self._threading = bool(threading)
        self._thread_count = int(thread_count)

        if build_index:
            self.build_keyframe_index()

        self._frame_height = int(self._stream.height or 0)
        self._frame_width = int(self._stream.width or 0)
        self._frame_shape = (self._frame_height, self._frame_width, 3)
        self._frame_rate = self._compute_frame_rate()
        self._nominal_frame_rate = self._compute_nominal_frame_rate()
        self._fourcc = self._compute_fourcc()
        self._frame_format = 0

    def close(self) -&gt; None:
        """Close the underlying PyAV container."""

        self._container.close()
        if self._fast_container is not None:
            self._fast_container.close()
            self._fast_container = None
            self._fast_stream = None
            self._fast_decoder = None
            self._fast_last_pts = None
        self._fast_first_frame_number = None
        if self._seq_container is not None:
            self._seq_container.close()
            self._seq_container = None
            self._seq_stream = None
            self._seq_decoder = None
        self._seq_frame_index = 0
        self._last_index = None
        self._last_fast_index = None

    def __enter__(self) -&gt; "PyAVVideoBackend":
        """Return self for context manager usage."""

        return self

    def __exit__(self, exc_type, exc, tb) -&gt; None:
        """Close the backend on exit from a context manager."""

        self.close()

    def _secs_to_pts(self, t_s: float) -&gt; int:
        """Convert seconds to presentation timestamp units."""

        ticks = int(round(t_s / float(self._time_base)))
        return self._start_pts + ticks

    def _pts_to_secs(self, pts: int) -&gt; float:
        """Convert presentation timestamp units to seconds."""

        return float((pts - self._start_pts) * self._time_base)

    def _pts_to_frame_number(self, pts: Optional[int], fps: float) -&gt; Optional[int]:
        """Convert a PTS value to a rounded frame number."""

        if pts is None:
            return None
        return int(round(self._pts_to_secs(int(pts)) * fps))

    def _frame_time_s(self, pts: Optional[int]) -&gt; float:
        """Return the timestamp for a frame PTS."""

        return float("nan") if pts is None else self._pts_to_secs(pts)

    def _flush_decoder(self) -&gt; None:
        """Flush decoder buffers if supported."""

        try:
            self._codec_ctx.flush_buffers()
        except Exception:
            pass

    def _compute_frame_rate(self) -&gt; float:
        """Compute the stream frame rate in frames per second."""

        rate = self._stream.average_rate or self._stream.base_rate
        return float(rate) if rate is not None else 0.0

    def _compute_nominal_frame_rate(self) -&gt; float:
        """Compute a nominal frame rate preferring guessed_rate (useful for VFR)."""

        rate = getattr(self._stream, "guessed_rate", None) or self._stream.average_rate or self._stream.base_rate
        return float(rate) if rate is not None else 0.0

    @property
    def nominal_frame_rate(self) -&gt; float:
        """Return the nominal frame rate (guessed_rate when available)."""

        return self._nominal_frame_rate

    def _compute_fourcc(self) -&gt; int:
        """Compute a fourcc code from the stream codec tag."""

        tag = self._stream.codec_context.codec_tag
        if isinstance(tag, str) and len(tag) &gt;= 4:
            tag = tag[:4]
            return (
                ord(tag[0])
                | (ord(tag[1]) &lt;&lt; 8)
                | (ord(tag[2]) &lt;&lt; 16)
                | (ord(tag[3]) &lt;&lt; 24)
            )
        return 0

    def _ensure_frame_pts(self) -&gt; None:
        """Decode the stream once to collect frame PTS values."""

        if self._frame_pts is not None:
            return
        idx_container = av.open(self._path)
        idx_stream = idx_container.streams.video[self._stream.index]
        self._configure_codec_context(idx_stream)
        self._configure_codec_context(idx_stream)
        pts_list: List[int] = []
        for frame in idx_container.decode(idx_stream):
            pts = frame.pts if frame.pts is not None else frame.dts
            if pts is None:
                pts = self._start_pts + len(pts_list)
            pts_list.append(int(pts))
        idx_container.close()
        self._frame_pts = pts_list
        self._frame_count = len(pts_list)

    def _read_frame_by_pts(self, target_pts: int, *, decode_rgb: bool = True) -&gt; DecodedFrame:
        """Decode the first frame at or after a target PTS."""

        cached = self._frame_cache.get(target_pts)
        if cached is not None:
            return cached  # type: ignore[return-value]

        if self._index_built:
            idx = self._keyframe_index_at_or_before_pts(target_pts)
            seek_pts = self._keyframes[idx].pts
        else:
            seek_pts = target_pts

        container = av.open(self._path)
        stream = container.streams.video[self._stream.index]
        self._configure_codec_context(stream)
        try:
            container.seek(seek_pts, stream=stream, backward=True, any_frame=False)
            try:
                stream.codec_context.flush_buffers()
            except Exception:
                pass

            last: Optional[DecodedFrame] = None
            for packet in container.demux(stream):
                for frame in packet.decode():
                    pts = frame.pts
                    image = frame.to_rgb().to_ndarray() if decode_rgb else frame.to_ndarray(format="bgr24")
                    cur = DecodedFrame(
                        image=image,
                        pts=pts,
                        time_s=self._frame_time_s(pts),
                        key_frame=bool(getattr(frame, "key_frame", False)),
                    )
                    if pts is not None:
                        self._frame_cache.put(int(pts), cur)
                    if pts is None:
                        last = cur
                        continue
                    if pts &gt;= target_pts:
                        return cur
                    last = cur
        finally:
            container.close()

        if last is not None:
            return last
        raise RuntimeError("Could not decode any frames after seeking.")

    def _read_frame_at_index(
        self,
        index: int,
        *,
        decode_rgb: bool = True,
        use_sequential: bool = True,
    ) -&gt; DecodedFrame:
        """Return the decoded frame at a zero-based index."""

        if use_sequential and index &gt;= 0:
            if self._seq_decoder is not None and index == self._seq_frame_index:
                return self.read_next_frame(decode_rgb=decode_rgb)
            if self._seq_decoder is None and index == 0:
                self.reset_sequence()
                return self.read_next_frame(decode_rgb=decode_rgb)

        self._ensure_frame_pts()
        assert self._frame_pts is not None
        if index &lt; 0:
            index += self._frame_count
        if index &lt; 0 or index &gt;= self._frame_count:
            raise IndexError("frame index out of range")
        target_pts = self._frame_pts[index]
        if use_sequential and self._seq_decoder is not None and index == self._seq_frame_index:
            try:
                decoded = self.read_next_frame(decode_rgb=decode_rgb)
            except StopIteration:
                decoded = self._seek_seq_to_pts(target_pts, target_index=index, decode_rgb=decode_rgb)
        elif use_sequential and self._last_index is not None and index == self._last_index + 1:
            decoded = self._seek_seq_to_pts(target_pts, target_index=index, decode_rgb=decode_rgb)
        else:
            decoded = self._read_frame_by_pts(target_pts, decode_rgb=decode_rgb)
            self._current_frame_pos = float(index)
        self._last_index = index
        return decoded

    def frame_at_index(self, index: int) -&gt; np.ndarray:
        """Return the decoded frame at a zero-based index."""

        return self._read_frame_at_index(index, decode_rgb=True, use_sequential=True).image

    #
    # Public helpers for PTS/time mapping
    #
    def pts_at_index(self, index: int) -&gt; Optional[int]:
        """Return the presentation timestamp (PTS) for a frame index."""

        self._ensure_frame_pts()
        assert self._frame_pts is not None
        if index &lt; 0:
            index += self._frame_count
        if index &lt; 0 or index &gt;= self._frame_count:
            raise IndexError("frame index out of range")
        return int(self._frame_pts[index])

    def time_at_index(self, index: int) -&gt; float:
        """Return the timestamp in seconds for a frame index."""

        pts = self.pts_at_index(index)
        return float("nan") if pts is None else self._pts_to_secs(int(pts))

    def index_from_pts(self, pts: int) -&gt; int:
        """Map a PTS value to the nearest frame index."""

        self._ensure_frame_pts()
        assert self._frame_pts is not None
        fps = self._frame_pts
        if not fps:
            return 0
        lo, hi = 0, len(fps) - 1
        if pts &lt;= fps[0]:
            return 0
        if pts &gt;= fps[-1]:
            return hi
        while lo &lt;= hi:
            mid = (lo + hi) // 2
            m = fps[mid]
            if m == pts:
                return mid
            if m &lt; pts:
                lo = mid + 1
            else:
                hi = mid - 1
        # choose nearest between hi and lo
        if lo &gt;= len(fps):
            return hi
        if hi &lt; 0:
            return lo
        return lo if abs(fps[lo] - pts) &lt; abs(fps[hi] - pts) else hi

    def index_from_time(self, t_s: float) -&gt; int:
        """Map a timestamp in seconds to the nearest frame index."""

        pts = self._secs_to_pts(float(t_s))
        return self.index_from_pts(int(pts))

    @property
    def frame_height(self) -&gt; int:
        """Return the video frame height."""

        return self._frame_height

    @property
    def frame_width(self) -&gt; int:
        """Return the video frame width."""

        return self._frame_width

    @property
    def frame_rate(self) -&gt; float:
        """Return the reported frame rate in frames per second."""

        return self._frame_rate

    @property
    def fourcc(self) -&gt; int:
        """Return the fourcc codec identifier."""

        return self._fourcc

    @property
    def frame_format(self) -&gt; int:
        """Return the frame format identifier."""

        return self._frame_format

    @property
    def number_of_frames(self) -&gt; int:
        """Return the total number of frames, decoding if needed."""

        if self._frame_count &lt;= 0:
            self._ensure_frame_pts()
        return self._frame_count

    @property
    def frame_shape(self) -&gt; tuple:
        """Return the expected frame shape (H, W, C)."""

        return self._frame_shape

    @property
    def current_frame_pos(self) -&gt; float:
        """Return the last frame index accessed."""

        return self._current_frame_pos

    def _seek_to_pts(self, pts: int, *, backward: bool) -&gt; None:
        """Seek to a timestamp in the stream."""

        self._container.seek(pts, stream=self._stream, backward=backward, any_frame=False)
        self._flush_decoder()

    def _ensure_fast_container(self) -&gt; None:
        """Initialize the fast-seek container if needed."""

        if self._fast_container is not None:
            return
        self._fast_container = av.open(self._path)
        self._fast_stream = self._fast_container.streams.video[self._stream.index]
        self._configure_codec_context(self._fast_stream)

    def _configure_codec_context(self, stream: av.video.stream.VideoStream) -&gt; None:
        """Apply conservative threading settings to a codec context."""

        try:
            codec_ctx = stream.codec_context
            if self._threading:
                codec_ctx.thread_type = "AUTO"
                codec_ctx.thread_count = self._thread_count
            else:
                codec_ctx.thread_type = "NONE"
                codec_ctx.thread_count = 1
        except Exception:
            pass

    def _fast_rewind(self) -&gt; None:
        """Rewind the fast-seek container and reset decoder state."""

        self._ensure_fast_container()
        assert self._fast_container is not None
        assert self._fast_stream is not None
        self._fast_container.seek(0)
        self._fast_decoder = self._fast_container.decode(self._fast_stream)
        self._fast_last_pts = None

    def _fast_frame_to_pts(self, frame_index: int, fps: float) -&gt; int:
        """Convert a frame index to expected PTS for fast reads."""

        if frame_index &lt;= 0:
            return self._start_pts
        return self._secs_to_pts(frame_index / fps)

    def _read_frame_fast_like(self, target_frame: int, *, decode_rgb: bool) -&gt; DecodedFrame:
        """Approximate FastVideoReader behavior for fast sequential reads."""

        fps = self._nominal_frame_rate or self._frame_rate or 1.0
        pts_per_frame = 1.0 / (fps * float(self._time_base)) if fps else 1.0
        wiggle = pts_per_frame / 10.0

        if target_frame &lt;= 0:
            self._fast_rewind()
            assert self._fast_decoder is not None
            frame = next(self._fast_decoder)
            pts = frame.pts if frame.pts is not None else frame.dts
            if pts is None:
                pts = self._fast_frame_to_pts(0, fps)
            img = frame.to_rgb().to_ndarray() if decode_rgb else frame.to_ndarray(format="bgr24")
            cur = DecodedFrame(
                image=img,
                pts=pts,
                time_s=self._frame_time_s(pts),
                key_frame=bool(getattr(frame, "key_frame", False)),
            )
            if pts is not None:
                self._frame_cache.put(int(pts), cur)
            return cur

        expected_prev_pts = self._fast_frame_to_pts(target_frame - 1, fps)
        if self._fast_decoder is not None and self._fast_last_pts == expected_prev_pts:
            try:
                frame = next(self._fast_decoder)
            except StopIteration:
                frame = None
            if frame is not None:
                pts = frame.pts if frame.pts is not None else frame.dts
                if pts is None:
                    pts = self._fast_frame_to_pts(target_frame, fps)
                img = frame.to_rgb().to_ndarray() if decode_rgb else frame.to_ndarray(format="bgr24")
                cur = DecodedFrame(
                    image=img,
                    pts=pts,
                    time_s=self._frame_time_s(pts),
                    key_frame=bool(getattr(frame, "key_frame", False)),
                )
                if pts is not None:
                    self._frame_cache.put(int(pts), cur)
                self._fast_last_pts = int(pts) if pts is not None else None
                return cur

        self._ensure_fast_container()
        assert self._fast_container is not None
        assert self._fast_stream is not None

        target_pts = self._fast_frame_to_pts(target_frame, fps)
        self._fast_container.seek(
            target_pts,
            stream=self._fast_stream,
            backward=True,
            any_frame=False,
        )
        try:
            self._fast_stream.codec_context.flush_buffers()
        except Exception:
            pass
        self._fast_decoder = self._fast_container.decode(self._fast_stream)
        self._fast_last_pts = None

        try:
            frame = next(self._fast_decoder)
        except StopIteration:
            frame = None
        if frame is None:
            return self._read_frame_fast_simple(target_pts, decode_rgb=decode_rgb)

        cur_pts = frame.pts if frame.pts is not None else frame.dts
        if cur_pts is None:
            cur_pts = target_pts

        if cur_pts &gt; target_pts:
            back = max(1, int(round(100)))
            back_pts = self._fast_frame_to_pts(max(0, target_frame - back), fps)
            self._fast_container.seek(
                back_pts,
                stream=self._fast_stream,
                backward=True,
                any_frame=False,
            )
            try:
                self._fast_stream.codec_context.flush_buffers()
            except Exception:
                pass
            self._fast_decoder = self._fast_container.decode(self._fast_stream)
            try:
                frame = next(self._fast_decoder)
            except StopIteration:
                frame = None
            if frame is None:
                return self._read_frame_fast_simple(target_pts, decode_rgb=decode_rgb)
            cur_pts = frame.pts if frame.pts is not None else frame.dts
            if cur_pts is None:
                cur_pts = target_pts

        while float(cur_pts) &lt; (float(target_pts) - wiggle):
            try:
                frame = next(self._fast_decoder)
            except StopIteration:
                frame = None
                break
            if frame is None:
                break
            cur_pts = frame.pts if frame.pts is not None else frame.dts
            if cur_pts is None:
                cur_pts = target_pts
                break

        if frame is None:
            return self._read_frame_fast_simple(target_pts, decode_rgb=decode_rgb)

        img = frame.to_rgb().to_ndarray() if decode_rgb else frame.to_ndarray(format="bgr24")
        cur = DecodedFrame(
            image=img,
            pts=cur_pts,
            time_s=self._frame_time_s(cur_pts),
            key_frame=bool(getattr(frame, "key_frame", False)),
        )
        if cur_pts is not None:
            self._frame_cache.put(int(cur_pts), cur)
            self._fast_last_pts = int(cur_pts)
        else:
            self._fast_last_pts = None
        return cur

    def _ensure_seq_container(self) -&gt; None:
        """Initialize a sequential decode container if needed."""

        if self._seq_container is not None:
            return
        self._seq_container = av.open(self._path)
        self._seq_stream = self._seq_container.streams.video[self._stream.index]
        self._configure_codec_context(self._seq_stream)
        self._seq_decoder = self._seq_container.decode(self._seq_stream)
        self._seq_frame_index = 0

    def reset_sequence(self) -&gt; None:
        """Reset sequential decoding to the first frame."""

        self._ensure_seq_container()
        assert self._seq_container is not None
        assert self._seq_stream is not None
        try:
            self._seq_container.seek(0)
        except Exception:
            pass
        self._seq_decoder = self._seq_container.decode(self._seq_stream)
        self._seq_frame_index = 0

    def _seek_seq_to_pts(
        self,
        target_pts: int,
        *,
        target_index: int,
        decode_rgb: bool,
        any_frame: bool = False,
    ) -&gt; DecodedFrame:
        """Seek the sequential decoder to a PTS and return the first match."""

        self._ensure_seq_container()
        assert self._seq_container is not None
        assert self._seq_stream is not None

        seek_pts = target_pts
        if self._keyframes and not any_frame:
            idx = self._keyframe_index_at_or_before_pts(target_pts)
            seek_pts = self._keyframes[idx].pts

        self._seq_container.seek(
            seek_pts,
            stream=self._seq_stream,
            backward=True,
            any_frame=any_frame,
        )
        try:
            self._seq_stream.codec_context.flush_buffers()
        except Exception:
            pass

        decoder = self._seq_container.decode(self._seq_stream)
        last: Optional[DecodedFrame] = None
        for frame in decoder:
            pts = frame.pts if frame.pts is not None else frame.dts
            img = frame.to_rgb().to_ndarray() if decode_rgb else frame.to_ndarray(format="bgr24")
            cur = DecodedFrame(
                image=img,
                pts=pts,
                time_s=self._frame_time_s(pts),
                key_frame=bool(getattr(frame, "key_frame", False)),
            )
            if pts is not None:
                self._frame_cache.put(int(pts), cur)
            if pts is None:
                last = cur
                continue
            if pts &gt;= target_pts:
                self._seq_decoder = decoder
                self._seq_frame_index = target_index + 1
                self._current_frame_pos = float(target_index)
                return cur
            last = cur

        if last is not None:
            self._seq_decoder = decoder
            self._seq_frame_index = target_index + 1
            self._current_frame_pos = float(target_index)
            return last
        raise RuntimeError("Could not decode any frames after seeking.")

    def build_keyframe_index(self, *, max_packets: Optional[int] = None) -&gt; List[KeyframeEntry]:
        """Scan packets and store keyframe pts/time."""

        path = self._container.name
        idx_container = av.open(path)
        idx_stream = idx_container.streams.video[self._stream.index]

        key_pts: List[int] = []
        n = 0
        for packet in idx_container.demux(idx_stream):
            if packet.dts is None and packet.pts is None:
                continue
            if packet.is_keyframe:
                pts = packet.pts if packet.pts is not None else packet.dts
                if pts is not None:
                    key_pts.append(int(pts))
            n += 1
            if max_packets is not None and n &gt;= max_packets:
                break

        idx_container.close()

        key_pts = sorted(set(key_pts))
        if not key_pts:
            key_pts = [self._start_pts]

        self._keyframes = [KeyframeEntry(pts=p, time_s=self._pts_to_secs(p)) for p in key_pts]
        self._index_built = True

        self._bucket_to_kfidx.clear()
        return self._keyframes

    def _keyframe_index_at_or_before_pts(self, target_pts: int) -&gt; int:
        """Return keyframe index at or before the target PTS."""

        kf = self._keyframes
        if not self._index_built or not kf:
            return 0
        if target_pts &lt;= kf[0].pts:
            return 0
        if target_pts &gt;= kf[-1].pts:
            return len(kf) - 1

        lo, hi = 0, len(kf) - 1
        while lo &lt;= hi:
            mid = (lo + hi) // 2
            m = kf[mid].pts
            if m == target_pts:
                return mid
            if m &lt; target_pts:
                lo = mid + 1
            else:
                hi = mid - 1
        return hi

    def _keyframe_index_nearest_pts(self, target_pts: int) -&gt; int:
        """Return nearest keyframe index to the target PTS."""

        kf = self._keyframes
        if not self._index_built or not kf:
            return 0
        i0 = self._keyframe_index_at_or_before_pts(target_pts)
        i1 = min(i0 + 1, len(kf) - 1)
        if i0 == i1:
            return i0
        d0 = abs(kf[i0].pts - target_pts)
        d1 = abs(kf[i1].pts - target_pts)
        return i0 if d0 &lt;= d1 else i1

    def _bucket_key(self, t_s: float) -&gt; int:
        """Return a bucket key for the scrub acceleration cache."""

        return int(round(t_s * 1000.0 / self._scrub_bucket_ms))

    def _keyframe_index_for_time_fast(self, t_s: float, mode: str) -&gt; int:
        """Return a keyframe index using cached time buckets."""

        if not self._index_built:
            raise RuntimeError("Keyframe index not built. Call build_keyframe_index() first.")

        b = self._bucket_key(t_s)

        mode_tag = {"previous": 0, "nearest": 1, "next": 2}.get(mode)
        if mode_tag is None:
            raise ValueError("mode must be one of: 'previous', 'nearest', 'next'")
        cache_key = (b &lt;&lt; 2) | mode_tag

        cached = self._bucket_to_kfidx.get(cache_key)
        if cached is not None:
            return int(cached)

        target_pts = self._secs_to_pts(t_s)

        if mode == "previous":
            idx = self._keyframe_index_at_or_before_pts(target_pts)
        elif mode == "nearest":
            idx = self._keyframe_index_nearest_pts(target_pts)
        else:
            i_prev = self._keyframe_index_at_or_before_pts(target_pts)
            if self._keyframes[i_prev].pts &gt;= target_pts:
                idx = i_prev
            else:
                idx = min(i_prev + 1, len(self._keyframes) - 1)

        self._bucket_to_kfidx.put(cache_key, idx)
        return idx

    def read_keyframe_at(
        self,
        t_s: Number,
        *,
        mode: str = "nearest",
        decode_rgb: bool = True,
    ) -&gt; DecodedFrame:
        """Return a nearby keyframe without GOP forward decoding."""

        t_s = float(t_s)
        idx = self._keyframe_index_for_time_fast(t_s, mode)
        key_pts = self._keyframes[idx].pts

        cached = self._frame_cache.get(key_pts)
        if cached is not None:
            return cached  # type: ignore[return-value]

        # Use a fresh container for reliable keyframe seek, avoiding stateful issues
        container = av.open(self._path)
        try:
            stream = container.streams.video[self._stream.index]
            self._configure_codec_context(stream)
            # Use backward seek to land on or before the requested keyframe PTS reliably
            container.seek(key_pts, stream=stream, backward=True, any_frame=False)
            try:
                stream.codec_context.flush_buffers()
            except Exception:
                pass

            for packet in container.demux(stream):
                for frame in packet.decode():
                    pts = frame.pts
                    img = frame.to_rgb().to_ndarray() if decode_rgb else frame.to_ndarray()
                    cur = DecodedFrame(
                        image=img,
                        pts=pts,
                        time_s=self._frame_time_s(pts),
                        key_frame=bool(getattr(frame, "key_frame", False)),
                    )
                    if pts is not None:
                        self._frame_cache.put(int(pts), cur)
                    return cur
        finally:
            container.close()

        raise RuntimeError("Failed to decode a frame after keyframe seek.")

    def read_frame_at(
        self,
        t_s: Number,
        *,
        return_first_after: bool = True,
        max_decode_frames: int = 10_000,
        use_index: bool = True,
    ) -&gt; DecodedFrame:
        """Decode a frame near a timestamp with accurate seeking.

        Simplified and robust: always uses a fresh container and backward keyframe seek.
        """

        t_s = float(t_s)
        target_pts = self._secs_to_pts(t_s)

        cached = self._frame_cache.get(target_pts)
        if cached is not None:
            return cached  # type: ignore[return-value]

        container = av.open(self._path)
        try:
            stream = container.streams.video[self._stream.index]
            self._configure_codec_context(stream)
            if use_index and self._index_built:
                idx = self._keyframe_index_at_or_before_pts(target_pts)
                anchor_pts = self._keyframes[idx].pts
                container.seek(anchor_pts, stream=stream, backward=True, any_frame=False)
            else:
                container.seek(target_pts, stream=stream, backward=True, any_frame=False)
            try:
                stream.codec_context.flush_buffers()
            except Exception:
                pass

            last: Optional[DecodedFrame] = None
            decoded = 0
            for packet in container.demux(stream):
                for frame in packet.decode():
                    decoded += 1
                    if decoded &gt; max_decode_frames:
                        raise RuntimeError(
                            "Exceeded max_decode_frames while seeking; timestamps may be broken."
                        )
                    pts = frame.pts
                    cur = DecodedFrame(
                        image=frame.to_rgb().to_ndarray(),
                        pts=pts,
                        time_s=self._frame_time_s(pts),
                        key_frame=bool(getattr(frame, "key_frame", False)),
                    )
                    if pts is not None:
                        self._frame_cache.put(int(pts), cur)
                    if pts is None:
                        last = cur
                        continue
                    if return_first_after:
                        if pts &gt;= target_pts:
                            return cur
                        last = cur
                    else:
                        if pts &lt;= target_pts:
                            last = cur
                        elif last is not None:
                            return last
            if last is not None:
                return last
            raise RuntimeError("Could not decode any frames after seeking.")
        finally:
            container.close()

    def _read_frame_fast_simple(self, target_pts: int, *, decode_rgb: bool) -&gt; DecodedFrame:
        """Fallback fast seek: seek and decode first frame after PTS."""

        self._ensure_fast_container()
        assert self._fast_container is not None
        assert self._fast_stream is not None

        def grab_frame(container: av.container.InputContainer, stream: av.video.stream.VideoStream) -&gt; Optional[DecodedFrame]:
            for frame in container.decode(stream):
                pts = frame.pts if frame.pts is not None else frame.dts
                if pts is None:
                    target_reached = True
                else:
                    target_reached = pts &gt;= target_pts
                if not target_reached:
                    continue
                if decode_rgb:
                    img = frame.to_rgb().to_ndarray()
                else:
                    img = frame.to_ndarray(format="bgr24")
                cur = DecodedFrame(
                    image=img,
                    pts=pts,
                    time_s=self._frame_time_s(pts),
                    key_frame=bool(getattr(frame, "key_frame", False)),
                )
                if pts is not None:
                    self._frame_cache.put(int(pts), cur)
                return cur
            return None

        self._fast_container.seek(
            target_pts,
            stream=self._fast_stream,
            backward=True,
            any_frame=True,
        )
        try:
            self._fast_stream.codec_context.flush_buffers()
        except Exception:
            pass
        grabbed = grab_frame(self._fast_container, self._fast_stream)
        if grabbed is not None:
            return grabbed

        self._fast_container.seek(
            target_pts,
            stream=self._fast_stream,
            backward=True,
            any_frame=False,
        )
        try:
            self._fast_stream.codec_context.flush_buffers()
        except Exception:
            pass
        grabbed = grab_frame(self._fast_container, self._fast_stream)
        if grabbed is not None:
            return grabbed

        raise RuntimeError("Failed to decode a frame after fast seek.")

    def _read_frame_fast_opencv_pyav(self, target_frame: int, *, decode_rgb: bool) -&gt; DecodedFrame:
        """Approximate OpenCV seek behavior using PyAV."""

        fps = self._nominal_frame_rate or self._frame_rate or 1.0
        self._ensure_fast_container()
        assert self._fast_container is not None
        assert self._fast_stream is not None

        def seek_to_frame(frame_index: int) -&gt; None:
            target_pts = self._secs_to_pts(frame_index / fps)
            self._fast_container.seek(
                target_pts,
                stream=self._fast_stream,
                backward=True,
                any_frame=False,
            )
            try:
                self._fast_stream.codec_context.flush_buffers()
            except Exception:
                pass

        def frame_number_from_pts(pts: Optional[int]) -&gt; Optional[int]:
            num = self._pts_to_frame_number(pts, fps)
            if num is None:
                return None
            if self._fast_first_frame_number is None:
                return num
            return num - self._fast_first_frame_number

        first_frame = None
        if self._fast_first_frame_number is None:
            seek_to_frame(0)
            for frame in self._fast_container.decode(self._fast_stream):
                pts = frame.pts if frame.pts is not None else frame.dts
                self._fast_first_frame_number = self._pts_to_frame_number(pts, fps) or 0
                first_frame = frame
                break

        if target_frame &lt;= 0:
            if first_frame is None:
                seek_to_frame(0)
                for frame in self._fast_container.decode(self._fast_stream):
                    first_frame = frame
                    break
            if first_frame is None:
                raise RuntimeError("Failed to decode a frame after fast seek.")
            pts = first_frame.pts if first_frame.pts is not None else first_frame.dts
            img = first_frame.to_rgb().to_ndarray() if decode_rgb else first_frame.to_ndarray(format="bgr24")
            cur = DecodedFrame(
                image=img,
                pts=pts,
                time_s=self._frame_time_s(pts),
                key_frame=bool(getattr(first_frame, "key_frame", False)),
            )
            if pts is not None:
                self._frame_cache.put(int(pts), cur)
            return cur

        delta = 16
        attempts = 0
        while True:
            start_frame = max(target_frame - delta, 0)
            seek_to_frame(start_frame)
            decoder = self._fast_container.decode(self._fast_stream)
            try:
                frame = next(decoder)
            except StopIteration:
                break

            pts = frame.pts if frame.pts is not None else frame.dts
            frame_number = frame_number_from_pts(pts)
            if frame_number is None:
                frame_number = start_frame

            if frame_number &lt; 0 or frame_number &gt; target_frame:
                if start_frame == 0 or delta &gt;= 1 &lt;&lt; 30 or attempts &gt; 20:
                    break
                delta = delta * 2 if delta &lt; 16 else int(delta * 1.5)
                attempts += 1
                continue

            while frame_number &lt; target_frame:
                try:
                    frame = next(decoder)
                except StopIteration:
                    frame = None
                    break
                pts = frame.pts if frame.pts is not None else frame.dts
                frame_number = frame_number_from_pts(pts)
                if frame_number is None:
                    frame_number = target_frame

            if frame is None:
                break

            pts = frame.pts if frame.pts is not None else frame.dts
            img = frame.to_rgb().to_ndarray() if decode_rgb else frame.to_ndarray(format="bgr24")
            cur = DecodedFrame(
                image=img,
                pts=pts,
                time_s=self._frame_time_s(pts),
                key_frame=bool(getattr(frame, "key_frame", False)),
            )
            if pts is not None:
                self._frame_cache.put(int(pts), cur)
            return cur

        target_pts = self._secs_to_pts(target_frame / fps)
        return self._read_frame_fast_simple(target_pts, decode_rgb=decode_rgb)


    def read_frame_fast(
        self,
        *,
        index: Optional[int] = None,
        t_s: Optional[Number] = None,
        decode_rgb: bool = True,
        use_sequential: bool = True,
    ) -&gt; DecodedFrame:
        """Return a fast, approximate frame for an index or timestamp."""

        if index is None and t_s is None:
            raise ValueError("Provide either index or t_s")
        if index is not None and t_s is not None:
            raise ValueError("Provide only one of index or t_s")

        if t_s is None:
            if index is None:
                raise ValueError("Provide either index or t_s")
            if index &lt; 0:
                index += self.number_of_frames
            target_frame = int(index)
        else:
            t_s = float(t_s)
            target_frame = int(round(t_s * (self._nominal_frame_rate or self._frame_rate or 1.0)))

        if use_sequential:
            decoded = self._read_frame_fast_like(target_frame, decode_rgb=decode_rgb)
            self._last_fast_index = target_frame
            return decoded

        fps = self._nominal_frame_rate or self._frame_rate or 1.0
        target_pts = self._secs_to_pts(target_frame / fps)
        cached = self._frame_cache.get(target_pts)
        if cached is not None:
            self._last_fast_index = target_frame
            return cached  # type: ignore[return-value]

        decoded = self._read_frame_fast_opencv_pyav(target_frame, decode_rgb=decode_rgb)
        self._last_fast_index = target_frame
        return decoded

    def read_frame(
        self,
        *,
        index: Optional[int] = None,
        t_s: Optional[Number] = None,
        mode: str = "accurate",
        decode_rgb: bool = True,
        keyframe_mode: str = "nearest",
        use_sequential: bool = True,
    ) -&gt; DecodedFrame:
        """Read a frame using a selectable access mode."""

        if mode not in {"accurate", "accurate_timeline", "fast", "scrub"}:
            raise ValueError("mode must be one of: 'accurate', 'accurate_timeline', 'fast', 'scrub'")
        if index is None and t_s is None:
            raise ValueError("Provide either index or t_s")
        if index is not None and t_s is not None:
            raise ValueError("Provide only one of index or t_s")

        if mode == "accurate":
            if index is not None:
                return self._read_frame_at_index(
                    int(index),
                    decode_rgb=decode_rgb,
                    use_sequential=use_sequential,
                )
            assert t_s is not None
            return self.read_frame_at(float(t_s), use_index=False)

        if mode == "accurate_timeline":
            if t_s is None:
                fps = self._nominal_frame_rate or self._frame_rate or 1.0
                t_s = float(index) / fps
            return self.read_frame_at(float(t_s))

        if mode == "scrub":
            if t_s is None:
                fps = self._frame_rate or 1.0
                t_s = float(index) / fps
            return self.read_keyframe_at(float(t_s), mode=keyframe_mode, decode_rgb=decode_rgb)

        return self.read_frame_fast(
            index=index,
            t_s=t_s,
            decode_rgb=decode_rgb,
            use_sequential=use_sequential,
        )

    def read_next_frame(self, *, decode_rgb: bool = True) -&gt; DecodedFrame:
        """Return the next frame using sequential decoding."""

        self._ensure_seq_container()
        assert self._seq_decoder is not None
        try:
            frame = next(self._seq_decoder)
        except StopIteration:
            raise
        pts = frame.pts if frame.pts is not None else frame.dts
        img = frame.to_rgb().to_ndarray() if decode_rgb else frame.to_ndarray(format="bgr24")
        cur = DecodedFrame(
            image=img,
            pts=pts,
            time_s=self._frame_time_s(pts),
            key_frame=bool(getattr(frame, "key_frame", False)),
        )
        if pts is not None:
            self._frame_cache.put(int(pts), cur)
        self._current_frame_pos = float(self._seq_frame_index)
        self._last_index = int(self._seq_frame_index)
        self._last_fast_index = int(self._seq_frame_index)
        self._seq_frame_index += 1
        return cur

    def iter_frames(self, *, decode_rgb: bool = True) -&gt; Iterator[DecodedFrame]:
        """Iterate through frames sequentially."""

        self.reset_sequence()
        assert self._seq_decoder is not None
        for frame in self._seq_decoder:
            pts = frame.pts if frame.pts is not None else frame.dts
            img = frame.to_rgb().to_ndarray() if decode_rgb else frame.to_ndarray(format="bgr24")
            cur = DecodedFrame(
                image=img,
                pts=pts,
                time_s=self._frame_time_s(pts),
                key_frame=bool(getattr(frame, "key_frame", False)),
            )
            if pts is not None:
                self._frame_cache.put(int(pts), cur)
            self._current_frame_pos = float(self._seq_frame_index)
            self._seq_frame_index += 1
            yield cur</code></pre>
              </details>



<div class="doc doc-children">







<div class="doc doc-object doc-attribute">



<h2 id="acvr._pyav_backend.PyAVVideoBackend._bucket_to_kfidx" class="doc doc-heading">
            <code class=" language-python">_bucket_to_kfidx = _LRU(scrub_bucket_lru_size)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h2>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h2 id="acvr._pyav_backend.PyAVVideoBackend._codec_ctx" class="doc doc-heading">
            <code class=" language-python">_codec_ctx = self._stream.codec_context</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h2>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h2 id="acvr._pyav_backend.PyAVVideoBackend._container" class="doc doc-heading">
            <code class=" language-python">_container = av.open(path)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h2>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h2 id="acvr._pyav_backend.PyAVVideoBackend._current_frame_pos" class="doc doc-heading">
            <code class=" language-python">_current_frame_pos = 0.0</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h2>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h2 id="acvr._pyav_backend.PyAVVideoBackend._fast_container" class="doc doc-heading">
            <code class=" language-python">_fast_container = None</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h2>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h2 id="acvr._pyav_backend.PyAVVideoBackend._fast_decoder" class="doc doc-heading">
            <code class=" language-python">_fast_decoder = None</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h2>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h2 id="acvr._pyav_backend.PyAVVideoBackend._fast_first_frame_number" class="doc doc-heading">
            <code class=" language-python">_fast_first_frame_number = None</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h2>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h2 id="acvr._pyav_backend.PyAVVideoBackend._fast_last_pts" class="doc doc-heading">
            <code class=" language-python">_fast_last_pts = None</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h2>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h2 id="acvr._pyav_backend.PyAVVideoBackend._fast_stream" class="doc doc-heading">
            <code class=" language-python">_fast_stream = None</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h2>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h2 id="acvr._pyav_backend.PyAVVideoBackend._fourcc" class="doc doc-heading">
            <code class=" language-python">_fourcc = self._compute_fourcc()</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h2>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h2 id="acvr._pyav_backend.PyAVVideoBackend._frame_cache" class="doc doc-heading">
            <code class=" language-python">_frame_cache = _LRU(decoded_frame_cache_size)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h2>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h2 id="acvr._pyav_backend.PyAVVideoBackend._frame_count" class="doc doc-heading">
            <code class=" language-python">_frame_count = int(self._stream.frames or 0)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h2>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h2 id="acvr._pyav_backend.PyAVVideoBackend._frame_format" class="doc doc-heading">
            <code class=" language-python">_frame_format = 0</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h2>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h2 id="acvr._pyav_backend.PyAVVideoBackend._frame_height" class="doc doc-heading">
            <code class=" language-python">_frame_height = int(self._stream.height or 0)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h2>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h2 id="acvr._pyav_backend.PyAVVideoBackend._frame_pts" class="doc doc-heading">
            <code class=" language-python">_frame_pts = None</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h2>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h2 id="acvr._pyav_backend.PyAVVideoBackend._frame_rate" class="doc doc-heading">
            <code class=" language-python">_frame_rate = self._compute_frame_rate()</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h2>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h2 id="acvr._pyav_backend.PyAVVideoBackend._frame_shape" class="doc doc-heading">
            <code class=" language-python">_frame_shape = (self._frame_height, self._frame_width, 3)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h2>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h2 id="acvr._pyav_backend.PyAVVideoBackend._frame_width" class="doc doc-heading">
            <code class=" language-python">_frame_width = int(self._stream.width or 0)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h2>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h2 id="acvr._pyav_backend.PyAVVideoBackend._index_built" class="doc doc-heading">
            <code class=" language-python">_index_built = False</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h2>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h2 id="acvr._pyav_backend.PyAVVideoBackend._keyframes" class="doc doc-heading">
            <code class=" language-python">_keyframes = []</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h2>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h2 id="acvr._pyav_backend.PyAVVideoBackend._last_fast_index" class="doc doc-heading">
            <code class=" language-python">_last_fast_index = None</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h2>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h2 id="acvr._pyav_backend.PyAVVideoBackend._last_index" class="doc doc-heading">
            <code class=" language-python">_last_index = None</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h2>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h2 id="acvr._pyav_backend.PyAVVideoBackend._nominal_frame_rate" class="doc doc-heading">
            <code class=" language-python">_nominal_frame_rate = self._compute_nominal_frame_rate()</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h2>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h2 id="acvr._pyav_backend.PyAVVideoBackend._path" class="doc doc-heading">
            <code class=" language-python">_path = path</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h2>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h2 id="acvr._pyav_backend.PyAVVideoBackend._scrub_bucket_ms" class="doc doc-heading">
            <code class=" language-python">_scrub_bucket_ms = max(1, int(scrub_bucket_ms))</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h2>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h2 id="acvr._pyav_backend.PyAVVideoBackend._seq_container" class="doc doc-heading">
            <code class=" language-python">_seq_container = None</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h2>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h2 id="acvr._pyav_backend.PyAVVideoBackend._seq_decoder" class="doc doc-heading">
            <code class=" language-python">_seq_decoder = None</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h2>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h2 id="acvr._pyav_backend.PyAVVideoBackend._seq_frame_index" class="doc doc-heading">
            <code class=" language-python">_seq_frame_index = 0</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h2>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h2 id="acvr._pyav_backend.PyAVVideoBackend._seq_stream" class="doc doc-heading">
            <code class=" language-python">_seq_stream = None</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h2>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h2 id="acvr._pyav_backend.PyAVVideoBackend._start_pts" class="doc doc-heading">
            <code class=" language-python">_start_pts = self._stream.start_time if self._stream.start_time is not None else 0</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h2>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h2 id="acvr._pyav_backend.PyAVVideoBackend._stream" class="doc doc-heading">
            <code class=" language-python">_stream = self._container.streams.video[video_stream_index]</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h2>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h2 id="acvr._pyav_backend.PyAVVideoBackend._thread_count" class="doc doc-heading">
            <code class=" language-python">_thread_count = int(thread_count)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h2>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h2 id="acvr._pyav_backend.PyAVVideoBackend._threading" class="doc doc-heading">
            <code class=" language-python">_threading = bool(threading)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h2>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h2 id="acvr._pyav_backend.PyAVVideoBackend._time_base" class="doc doc-heading">
            <code class=" language-python">_time_base = self._stream.time_base</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h2>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h2 id="acvr._pyav_backend.PyAVVideoBackend.current_frame_pos" class="doc doc-heading">
            <code class=" language-python">current_frame_pos</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h2>


    <div class="doc doc-contents ">

        <p>Return the last frame index accessed.</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h2 id="acvr._pyav_backend.PyAVVideoBackend.fourcc" class="doc doc-heading">
            <code class=" language-python">fourcc</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h2>


    <div class="doc doc-contents ">

        <p>Return the fourcc codec identifier.</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h2 id="acvr._pyav_backend.PyAVVideoBackend.frame_format" class="doc doc-heading">
            <code class=" language-python">frame_format</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h2>


    <div class="doc doc-contents ">

        <p>Return the frame format identifier.</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h2 id="acvr._pyav_backend.PyAVVideoBackend.frame_height" class="doc doc-heading">
            <code class=" language-python">frame_height</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h2>


    <div class="doc doc-contents ">

        <p>Return the video frame height.</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h2 id="acvr._pyav_backend.PyAVVideoBackend.frame_rate" class="doc doc-heading">
            <code class=" language-python">frame_rate</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h2>


    <div class="doc doc-contents ">

        <p>Return the reported frame rate in frames per second.</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h2 id="acvr._pyav_backend.PyAVVideoBackend.frame_shape" class="doc doc-heading">
            <code class=" language-python">frame_shape</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h2>


    <div class="doc doc-contents ">

        <p>Return the expected frame shape (H, W, C).</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h2 id="acvr._pyav_backend.PyAVVideoBackend.frame_width" class="doc doc-heading">
            <code class=" language-python">frame_width</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h2>


    <div class="doc doc-contents ">

        <p>Return the video frame width.</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h2 id="acvr._pyav_backend.PyAVVideoBackend.nominal_frame_rate" class="doc doc-heading">
            <code class=" language-python">nominal_frame_rate</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h2>


    <div class="doc doc-contents ">

        <p>Return the nominal frame rate (guessed_rate when available).</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h2 id="acvr._pyav_backend.PyAVVideoBackend.number_of_frames" class="doc doc-heading">
            <code class=" language-python">number_of_frames</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h2>


    <div class="doc doc-contents ">

        <p>Return the total number of frames, decoding if needed.</p>

    </div>

</div>




<div class="doc doc-object doc-function">


<h2 id="acvr._pyav_backend.PyAVVideoBackend.__enter__" class="doc doc-heading">
            <code class=" language-python">__enter__()</code>

</h2>


    <div class="doc doc-contents ">

        <p>Return self for context manager usage.</p>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>acvr/_pyav_backend.py</code></summary>
              <pre class="codehilite"><code class="language-python">def __enter__(self) -&gt; "PyAVVideoBackend":
    """Return self for context manager usage."""

    return self</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="acvr._pyav_backend.PyAVVideoBackend.__exit__" class="doc doc-heading">
            <code class=" language-python">__exit__(exc_type, exc, tb)</code>

</h2>


    <div class="doc doc-contents ">

        <p>Close the backend on exit from a context manager.</p>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>acvr/_pyav_backend.py</code></summary>
              <pre class="codehilite"><code class="language-python">def __exit__(self, exc_type, exc, tb) -&gt; None:
    """Close the backend on exit from a context manager."""

    self.close()</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="acvr._pyav_backend.PyAVVideoBackend.__init__" class="doc doc-heading">
            <code class=" language-python">__init__(path, video_stream_index=0, *, build_index=False, decoded_frame_cache_size=0, scrub_bucket_ms=25, scrub_bucket_lru_size=4096, threading=True, thread_count=0)</code>

</h2>


    <div class="doc doc-contents ">

        <p>Initialize the PyAV-backed decoder.</p>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>acvr/_pyav_backend.py</code></summary>
              <pre class="codehilite"><code class="language-python">def __init__(
    self,
    path: str,
    video_stream_index: int = 0,
    *,
    build_index: bool = False,
    decoded_frame_cache_size: int = 0,
    scrub_bucket_ms: int = 25,
    scrub_bucket_lru_size: int = 4096,
    threading: bool = True,
    thread_count: int = 0,
) -&gt; None:
    """Initialize the PyAV-backed decoder."""

    self._path = path
    self._container = av.open(path)
    self._stream = self._container.streams.video[video_stream_index]
    self._codec_ctx = self._stream.codec_context
    self._fast_container: Optional[av.container.InputContainer] = None
    self._fast_stream: Optional[av.video.stream.VideoStream] = None
    self._fast_first_frame_number: Optional[int] = None
    self._fast_decoder = None
    self._fast_last_pts: Optional[int] = None
    self._seq_container: Optional[av.container.InputContainer] = None
    self._seq_stream: Optional[av.video.stream.VideoStream] = None
    self._seq_decoder = None
    self._seq_frame_index: int = 0
    self._last_index: Optional[int] = None
    self._last_fast_index: Optional[int] = None

    self._time_base: Fraction = self._stream.time_base
    self._start_pts: int = self._stream.start_time if self._stream.start_time is not None else 0

    self._keyframes: List[KeyframeEntry] = []
    self._index_built: bool = False

    self._frame_pts: Optional[List[int]] = None
    self._frame_count: int = int(self._stream.frames or 0)
    self._current_frame_pos: float = 0.0

    self._frame_cache = _LRU(decoded_frame_cache_size)

    self._scrub_bucket_ms = max(1, int(scrub_bucket_ms))
    self._bucket_to_kfidx = _LRU(scrub_bucket_lru_size)
    self._threading = bool(threading)
    self._thread_count = int(thread_count)

    if build_index:
        self.build_keyframe_index()

    self._frame_height = int(self._stream.height or 0)
    self._frame_width = int(self._stream.width or 0)
    self._frame_shape = (self._frame_height, self._frame_width, 3)
    self._frame_rate = self._compute_frame_rate()
    self._nominal_frame_rate = self._compute_nominal_frame_rate()
    self._fourcc = self._compute_fourcc()
    self._frame_format = 0</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="acvr._pyav_backend.PyAVVideoBackend._bucket_key" class="doc doc-heading">
            <code class=" language-python">_bucket_key(t_s)</code>

</h2>


    <div class="doc doc-contents ">

        <p>Return a bucket key for the scrub acceleration cache.</p>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>acvr/_pyav_backend.py</code></summary>
              <pre class="codehilite"><code class="language-python">def _bucket_key(self, t_s: float) -&gt; int:
    """Return a bucket key for the scrub acceleration cache."""

    return int(round(t_s * 1000.0 / self._scrub_bucket_ms))</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="acvr._pyav_backend.PyAVVideoBackend._compute_fourcc" class="doc doc-heading">
            <code class=" language-python">_compute_fourcc()</code>

</h2>


    <div class="doc doc-contents ">

        <p>Compute a fourcc code from the stream codec tag.</p>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>acvr/_pyav_backend.py</code></summary>
              <pre class="codehilite"><code class="language-python">def _compute_fourcc(self) -&gt; int:
    """Compute a fourcc code from the stream codec tag."""

    tag = self._stream.codec_context.codec_tag
    if isinstance(tag, str) and len(tag) &gt;= 4:
        tag = tag[:4]
        return (
            ord(tag[0])
            | (ord(tag[1]) &lt;&lt; 8)
            | (ord(tag[2]) &lt;&lt; 16)
            | (ord(tag[3]) &lt;&lt; 24)
        )
    return 0</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="acvr._pyav_backend.PyAVVideoBackend._compute_frame_rate" class="doc doc-heading">
            <code class=" language-python">_compute_frame_rate()</code>

</h2>


    <div class="doc doc-contents ">

        <p>Compute the stream frame rate in frames per second.</p>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>acvr/_pyav_backend.py</code></summary>
              <pre class="codehilite"><code class="language-python">def _compute_frame_rate(self) -&gt; float:
    """Compute the stream frame rate in frames per second."""

    rate = self._stream.average_rate or self._stream.base_rate
    return float(rate) if rate is not None else 0.0</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="acvr._pyav_backend.PyAVVideoBackend._compute_nominal_frame_rate" class="doc doc-heading">
            <code class=" language-python">_compute_nominal_frame_rate()</code>

</h2>


    <div class="doc doc-contents ">

        <p>Compute a nominal frame rate preferring guessed_rate (useful for VFR).</p>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>acvr/_pyav_backend.py</code></summary>
              <pre class="codehilite"><code class="language-python">def _compute_nominal_frame_rate(self) -&gt; float:
    """Compute a nominal frame rate preferring guessed_rate (useful for VFR)."""

    rate = getattr(self._stream, "guessed_rate", None) or self._stream.average_rate or self._stream.base_rate
    return float(rate) if rate is not None else 0.0</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="acvr._pyav_backend.PyAVVideoBackend._configure_codec_context" class="doc doc-heading">
            <code class=" language-python">_configure_codec_context(stream)</code>

</h2>


    <div class="doc doc-contents ">

        <p>Apply conservative threading settings to a codec context.</p>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>acvr/_pyav_backend.py</code></summary>
              <pre class="codehilite"><code class="language-python">def _configure_codec_context(self, stream: av.video.stream.VideoStream) -&gt; None:
    """Apply conservative threading settings to a codec context."""

    try:
        codec_ctx = stream.codec_context
        if self._threading:
            codec_ctx.thread_type = "AUTO"
            codec_ctx.thread_count = self._thread_count
        else:
            codec_ctx.thread_type = "NONE"
            codec_ctx.thread_count = 1
    except Exception:
        pass</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="acvr._pyav_backend.PyAVVideoBackend._ensure_fast_container" class="doc doc-heading">
            <code class=" language-python">_ensure_fast_container()</code>

</h2>


    <div class="doc doc-contents ">

        <p>Initialize the fast-seek container if needed.</p>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>acvr/_pyav_backend.py</code></summary>
              <pre class="codehilite"><code class="language-python">def _ensure_fast_container(self) -&gt; None:
    """Initialize the fast-seek container if needed."""

    if self._fast_container is not None:
        return
    self._fast_container = av.open(self._path)
    self._fast_stream = self._fast_container.streams.video[self._stream.index]
    self._configure_codec_context(self._fast_stream)</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="acvr._pyav_backend.PyAVVideoBackend._ensure_frame_pts" class="doc doc-heading">
            <code class=" language-python">_ensure_frame_pts()</code>

</h2>


    <div class="doc doc-contents ">

        <p>Decode the stream once to collect frame PTS values.</p>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>acvr/_pyav_backend.py</code></summary>
              <pre class="codehilite"><code class="language-python">def _ensure_frame_pts(self) -&gt; None:
    """Decode the stream once to collect frame PTS values."""

    if self._frame_pts is not None:
        return
    idx_container = av.open(self._path)
    idx_stream = idx_container.streams.video[self._stream.index]
    self._configure_codec_context(idx_stream)
    self._configure_codec_context(idx_stream)
    pts_list: List[int] = []
    for frame in idx_container.decode(idx_stream):
        pts = frame.pts if frame.pts is not None else frame.dts
        if pts is None:
            pts = self._start_pts + len(pts_list)
        pts_list.append(int(pts))
    idx_container.close()
    self._frame_pts = pts_list
    self._frame_count = len(pts_list)</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="acvr._pyav_backend.PyAVVideoBackend._ensure_seq_container" class="doc doc-heading">
            <code class=" language-python">_ensure_seq_container()</code>

</h2>


    <div class="doc doc-contents ">

        <p>Initialize a sequential decode container if needed.</p>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>acvr/_pyav_backend.py</code></summary>
              <pre class="codehilite"><code class="language-python">def _ensure_seq_container(self) -&gt; None:
    """Initialize a sequential decode container if needed."""

    if self._seq_container is not None:
        return
    self._seq_container = av.open(self._path)
    self._seq_stream = self._seq_container.streams.video[self._stream.index]
    self._configure_codec_context(self._seq_stream)
    self._seq_decoder = self._seq_container.decode(self._seq_stream)
    self._seq_frame_index = 0</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="acvr._pyav_backend.PyAVVideoBackend._fast_frame_to_pts" class="doc doc-heading">
            <code class=" language-python">_fast_frame_to_pts(frame_index, fps)</code>

</h2>


    <div class="doc doc-contents ">

        <p>Convert a frame index to expected PTS for fast reads.</p>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>acvr/_pyav_backend.py</code></summary>
              <pre class="codehilite"><code class="language-python">def _fast_frame_to_pts(self, frame_index: int, fps: float) -&gt; int:
    """Convert a frame index to expected PTS for fast reads."""

    if frame_index &lt;= 0:
        return self._start_pts
    return self._secs_to_pts(frame_index / fps)</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="acvr._pyav_backend.PyAVVideoBackend._fast_rewind" class="doc doc-heading">
            <code class=" language-python">_fast_rewind()</code>

</h2>


    <div class="doc doc-contents ">

        <p>Rewind the fast-seek container and reset decoder state.</p>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>acvr/_pyav_backend.py</code></summary>
              <pre class="codehilite"><code class="language-python">def _fast_rewind(self) -&gt; None:
    """Rewind the fast-seek container and reset decoder state."""

    self._ensure_fast_container()
    assert self._fast_container is not None
    assert self._fast_stream is not None
    self._fast_container.seek(0)
    self._fast_decoder = self._fast_container.decode(self._fast_stream)
    self._fast_last_pts = None</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="acvr._pyav_backend.PyAVVideoBackend._flush_decoder" class="doc doc-heading">
            <code class=" language-python">_flush_decoder()</code>

</h2>


    <div class="doc doc-contents ">

        <p>Flush decoder buffers if supported.</p>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>acvr/_pyav_backend.py</code></summary>
              <pre class="codehilite"><code class="language-python">def _flush_decoder(self) -&gt; None:
    """Flush decoder buffers if supported."""

    try:
        self._codec_ctx.flush_buffers()
    except Exception:
        pass</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="acvr._pyav_backend.PyAVVideoBackend._frame_time_s" class="doc doc-heading">
            <code class=" language-python">_frame_time_s(pts)</code>

</h2>


    <div class="doc doc-contents ">

        <p>Return the timestamp for a frame PTS.</p>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>acvr/_pyav_backend.py</code></summary>
              <pre class="codehilite"><code class="language-python">def _frame_time_s(self, pts: Optional[int]) -&gt; float:
    """Return the timestamp for a frame PTS."""

    return float("nan") if pts is None else self._pts_to_secs(pts)</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="acvr._pyav_backend.PyAVVideoBackend._keyframe_index_at_or_before_pts" class="doc doc-heading">
            <code class=" language-python">_keyframe_index_at_or_before_pts(target_pts)</code>

</h2>


    <div class="doc doc-contents ">

        <p>Return keyframe index at or before the target PTS.</p>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>acvr/_pyav_backend.py</code></summary>
              <pre class="codehilite"><code class="language-python">def _keyframe_index_at_or_before_pts(self, target_pts: int) -&gt; int:
    """Return keyframe index at or before the target PTS."""

    kf = self._keyframes
    if not self._index_built or not kf:
        return 0
    if target_pts &lt;= kf[0].pts:
        return 0
    if target_pts &gt;= kf[-1].pts:
        return len(kf) - 1

    lo, hi = 0, len(kf) - 1
    while lo &lt;= hi:
        mid = (lo + hi) // 2
        m = kf[mid].pts
        if m == target_pts:
            return mid
        if m &lt; target_pts:
            lo = mid + 1
        else:
            hi = mid - 1
    return hi</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="acvr._pyav_backend.PyAVVideoBackend._keyframe_index_for_time_fast" class="doc doc-heading">
            <code class=" language-python">_keyframe_index_for_time_fast(t_s, mode)</code>

</h2>


    <div class="doc doc-contents ">

        <p>Return a keyframe index using cached time buckets.</p>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>acvr/_pyav_backend.py</code></summary>
              <pre class="codehilite"><code class="language-python">def _keyframe_index_for_time_fast(self, t_s: float, mode: str) -&gt; int:
    """Return a keyframe index using cached time buckets."""

    if not self._index_built:
        raise RuntimeError("Keyframe index not built. Call build_keyframe_index() first.")

    b = self._bucket_key(t_s)

    mode_tag = {"previous": 0, "nearest": 1, "next": 2}.get(mode)
    if mode_tag is None:
        raise ValueError("mode must be one of: 'previous', 'nearest', 'next'")
    cache_key = (b &lt;&lt; 2) | mode_tag

    cached = self._bucket_to_kfidx.get(cache_key)
    if cached is not None:
        return int(cached)

    target_pts = self._secs_to_pts(t_s)

    if mode == "previous":
        idx = self._keyframe_index_at_or_before_pts(target_pts)
    elif mode == "nearest":
        idx = self._keyframe_index_nearest_pts(target_pts)
    else:
        i_prev = self._keyframe_index_at_or_before_pts(target_pts)
        if self._keyframes[i_prev].pts &gt;= target_pts:
            idx = i_prev
        else:
            idx = min(i_prev + 1, len(self._keyframes) - 1)

    self._bucket_to_kfidx.put(cache_key, idx)
    return idx</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="acvr._pyav_backend.PyAVVideoBackend._keyframe_index_nearest_pts" class="doc doc-heading">
            <code class=" language-python">_keyframe_index_nearest_pts(target_pts)</code>

</h2>


    <div class="doc doc-contents ">

        <p>Return nearest keyframe index to the target PTS.</p>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>acvr/_pyav_backend.py</code></summary>
              <pre class="codehilite"><code class="language-python">def _keyframe_index_nearest_pts(self, target_pts: int) -&gt; int:
    """Return nearest keyframe index to the target PTS."""

    kf = self._keyframes
    if not self._index_built or not kf:
        return 0
    i0 = self._keyframe_index_at_or_before_pts(target_pts)
    i1 = min(i0 + 1, len(kf) - 1)
    if i0 == i1:
        return i0
    d0 = abs(kf[i0].pts - target_pts)
    d1 = abs(kf[i1].pts - target_pts)
    return i0 if d0 &lt;= d1 else i1</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="acvr._pyav_backend.PyAVVideoBackend._pts_to_frame_number" class="doc doc-heading">
            <code class=" language-python">_pts_to_frame_number(pts, fps)</code>

</h2>


    <div class="doc doc-contents ">

        <p>Convert a PTS value to a rounded frame number.</p>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>acvr/_pyav_backend.py</code></summary>
              <pre class="codehilite"><code class="language-python">def _pts_to_frame_number(self, pts: Optional[int], fps: float) -&gt; Optional[int]:
    """Convert a PTS value to a rounded frame number."""

    if pts is None:
        return None
    return int(round(self._pts_to_secs(int(pts)) * fps))</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="acvr._pyav_backend.PyAVVideoBackend._pts_to_secs" class="doc doc-heading">
            <code class=" language-python">_pts_to_secs(pts)</code>

</h2>


    <div class="doc doc-contents ">

        <p>Convert presentation timestamp units to seconds.</p>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>acvr/_pyav_backend.py</code></summary>
              <pre class="codehilite"><code class="language-python">def _pts_to_secs(self, pts: int) -&gt; float:
    """Convert presentation timestamp units to seconds."""

    return float((pts - self._start_pts) * self._time_base)</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="acvr._pyav_backend.PyAVVideoBackend._read_frame_at_index" class="doc doc-heading">
            <code class=" language-python">_read_frame_at_index(index, *, decode_rgb=True, use_sequential=True)</code>

</h2>


    <div class="doc doc-contents ">

        <p>Return the decoded frame at a zero-based index.</p>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>acvr/_pyav_backend.py</code></summary>
              <pre class="codehilite"><code class="language-python">def _read_frame_at_index(
    self,
    index: int,
    *,
    decode_rgb: bool = True,
    use_sequential: bool = True,
) -&gt; DecodedFrame:
    """Return the decoded frame at a zero-based index."""

    if use_sequential and index &gt;= 0:
        if self._seq_decoder is not None and index == self._seq_frame_index:
            return self.read_next_frame(decode_rgb=decode_rgb)
        if self._seq_decoder is None and index == 0:
            self.reset_sequence()
            return self.read_next_frame(decode_rgb=decode_rgb)

    self._ensure_frame_pts()
    assert self._frame_pts is not None
    if index &lt; 0:
        index += self._frame_count
    if index &lt; 0 or index &gt;= self._frame_count:
        raise IndexError("frame index out of range")
    target_pts = self._frame_pts[index]
    if use_sequential and self._seq_decoder is not None and index == self._seq_frame_index:
        try:
            decoded = self.read_next_frame(decode_rgb=decode_rgb)
        except StopIteration:
            decoded = self._seek_seq_to_pts(target_pts, target_index=index, decode_rgb=decode_rgb)
    elif use_sequential and self._last_index is not None and index == self._last_index + 1:
        decoded = self._seek_seq_to_pts(target_pts, target_index=index, decode_rgb=decode_rgb)
    else:
        decoded = self._read_frame_by_pts(target_pts, decode_rgb=decode_rgb)
        self._current_frame_pos = float(index)
    self._last_index = index
    return decoded</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="acvr._pyav_backend.PyAVVideoBackend._read_frame_by_pts" class="doc doc-heading">
            <code class=" language-python">_read_frame_by_pts(target_pts, *, decode_rgb=True)</code>

</h2>


    <div class="doc doc-contents ">

        <p>Decode the first frame at or after a target PTS.</p>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>acvr/_pyav_backend.py</code></summary>
              <pre class="codehilite"><code class="language-python">def _read_frame_by_pts(self, target_pts: int, *, decode_rgb: bool = True) -&gt; DecodedFrame:
    """Decode the first frame at or after a target PTS."""

    cached = self._frame_cache.get(target_pts)
    if cached is not None:
        return cached  # type: ignore[return-value]

    if self._index_built:
        idx = self._keyframe_index_at_or_before_pts(target_pts)
        seek_pts = self._keyframes[idx].pts
    else:
        seek_pts = target_pts

    container = av.open(self._path)
    stream = container.streams.video[self._stream.index]
    self._configure_codec_context(stream)
    try:
        container.seek(seek_pts, stream=stream, backward=True, any_frame=False)
        try:
            stream.codec_context.flush_buffers()
        except Exception:
            pass

        last: Optional[DecodedFrame] = None
        for packet in container.demux(stream):
            for frame in packet.decode():
                pts = frame.pts
                image = frame.to_rgb().to_ndarray() if decode_rgb else frame.to_ndarray(format="bgr24")
                cur = DecodedFrame(
                    image=image,
                    pts=pts,
                    time_s=self._frame_time_s(pts),
                    key_frame=bool(getattr(frame, "key_frame", False)),
                )
                if pts is not None:
                    self._frame_cache.put(int(pts), cur)
                if pts is None:
                    last = cur
                    continue
                if pts &gt;= target_pts:
                    return cur
                last = cur
    finally:
        container.close()

    if last is not None:
        return last
    raise RuntimeError("Could not decode any frames after seeking.")</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="acvr._pyav_backend.PyAVVideoBackend._read_frame_fast_like" class="doc doc-heading">
            <code class=" language-python">_read_frame_fast_like(target_frame, *, decode_rgb)</code>

</h2>


    <div class="doc doc-contents ">

        <p>Approximate FastVideoReader behavior for fast sequential reads.</p>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>acvr/_pyav_backend.py</code></summary>
              <pre class="codehilite"><code class="language-python">def _read_frame_fast_like(self, target_frame: int, *, decode_rgb: bool) -&gt; DecodedFrame:
    """Approximate FastVideoReader behavior for fast sequential reads."""

    fps = self._nominal_frame_rate or self._frame_rate or 1.0
    pts_per_frame = 1.0 / (fps * float(self._time_base)) if fps else 1.0
    wiggle = pts_per_frame / 10.0

    if target_frame &lt;= 0:
        self._fast_rewind()
        assert self._fast_decoder is not None
        frame = next(self._fast_decoder)
        pts = frame.pts if frame.pts is not None else frame.dts
        if pts is None:
            pts = self._fast_frame_to_pts(0, fps)
        img = frame.to_rgb().to_ndarray() if decode_rgb else frame.to_ndarray(format="bgr24")
        cur = DecodedFrame(
            image=img,
            pts=pts,
            time_s=self._frame_time_s(pts),
            key_frame=bool(getattr(frame, "key_frame", False)),
        )
        if pts is not None:
            self._frame_cache.put(int(pts), cur)
        return cur

    expected_prev_pts = self._fast_frame_to_pts(target_frame - 1, fps)
    if self._fast_decoder is not None and self._fast_last_pts == expected_prev_pts:
        try:
            frame = next(self._fast_decoder)
        except StopIteration:
            frame = None
        if frame is not None:
            pts = frame.pts if frame.pts is not None else frame.dts
            if pts is None:
                pts = self._fast_frame_to_pts(target_frame, fps)
            img = frame.to_rgb().to_ndarray() if decode_rgb else frame.to_ndarray(format="bgr24")
            cur = DecodedFrame(
                image=img,
                pts=pts,
                time_s=self._frame_time_s(pts),
                key_frame=bool(getattr(frame, "key_frame", False)),
            )
            if pts is not None:
                self._frame_cache.put(int(pts), cur)
            self._fast_last_pts = int(pts) if pts is not None else None
            return cur

    self._ensure_fast_container()
    assert self._fast_container is not None
    assert self._fast_stream is not None

    target_pts = self._fast_frame_to_pts(target_frame, fps)
    self._fast_container.seek(
        target_pts,
        stream=self._fast_stream,
        backward=True,
        any_frame=False,
    )
    try:
        self._fast_stream.codec_context.flush_buffers()
    except Exception:
        pass
    self._fast_decoder = self._fast_container.decode(self._fast_stream)
    self._fast_last_pts = None

    try:
        frame = next(self._fast_decoder)
    except StopIteration:
        frame = None
    if frame is None:
        return self._read_frame_fast_simple(target_pts, decode_rgb=decode_rgb)

    cur_pts = frame.pts if frame.pts is not None else frame.dts
    if cur_pts is None:
        cur_pts = target_pts

    if cur_pts &gt; target_pts:
        back = max(1, int(round(100)))
        back_pts = self._fast_frame_to_pts(max(0, target_frame - back), fps)
        self._fast_container.seek(
            back_pts,
            stream=self._fast_stream,
            backward=True,
            any_frame=False,
        )
        try:
            self._fast_stream.codec_context.flush_buffers()
        except Exception:
            pass
        self._fast_decoder = self._fast_container.decode(self._fast_stream)
        try:
            frame = next(self._fast_decoder)
        except StopIteration:
            frame = None
        if frame is None:
            return self._read_frame_fast_simple(target_pts, decode_rgb=decode_rgb)
        cur_pts = frame.pts if frame.pts is not None else frame.dts
        if cur_pts is None:
            cur_pts = target_pts

    while float(cur_pts) &lt; (float(target_pts) - wiggle):
        try:
            frame = next(self._fast_decoder)
        except StopIteration:
            frame = None
            break
        if frame is None:
            break
        cur_pts = frame.pts if frame.pts is not None else frame.dts
        if cur_pts is None:
            cur_pts = target_pts
            break

    if frame is None:
        return self._read_frame_fast_simple(target_pts, decode_rgb=decode_rgb)

    img = frame.to_rgb().to_ndarray() if decode_rgb else frame.to_ndarray(format="bgr24")
    cur = DecodedFrame(
        image=img,
        pts=cur_pts,
        time_s=self._frame_time_s(cur_pts),
        key_frame=bool(getattr(frame, "key_frame", False)),
    )
    if cur_pts is not None:
        self._frame_cache.put(int(cur_pts), cur)
        self._fast_last_pts = int(cur_pts)
    else:
        self._fast_last_pts = None
    return cur</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="acvr._pyav_backend.PyAVVideoBackend._read_frame_fast_opencv_pyav" class="doc doc-heading">
            <code class=" language-python">_read_frame_fast_opencv_pyav(target_frame, *, decode_rgb)</code>

</h2>


    <div class="doc doc-contents ">

        <p>Approximate OpenCV seek behavior using PyAV.</p>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>acvr/_pyav_backend.py</code></summary>
              <pre class="codehilite"><code class="language-python">def _read_frame_fast_opencv_pyav(self, target_frame: int, *, decode_rgb: bool) -&gt; DecodedFrame:
    """Approximate OpenCV seek behavior using PyAV."""

    fps = self._nominal_frame_rate or self._frame_rate or 1.0
    self._ensure_fast_container()
    assert self._fast_container is not None
    assert self._fast_stream is not None

    def seek_to_frame(frame_index: int) -&gt; None:
        target_pts = self._secs_to_pts(frame_index / fps)
        self._fast_container.seek(
            target_pts,
            stream=self._fast_stream,
            backward=True,
            any_frame=False,
        )
        try:
            self._fast_stream.codec_context.flush_buffers()
        except Exception:
            pass

    def frame_number_from_pts(pts: Optional[int]) -&gt; Optional[int]:
        num = self._pts_to_frame_number(pts, fps)
        if num is None:
            return None
        if self._fast_first_frame_number is None:
            return num
        return num - self._fast_first_frame_number

    first_frame = None
    if self._fast_first_frame_number is None:
        seek_to_frame(0)
        for frame in self._fast_container.decode(self._fast_stream):
            pts = frame.pts if frame.pts is not None else frame.dts
            self._fast_first_frame_number = self._pts_to_frame_number(pts, fps) or 0
            first_frame = frame
            break

    if target_frame &lt;= 0:
        if first_frame is None:
            seek_to_frame(0)
            for frame in self._fast_container.decode(self._fast_stream):
                first_frame = frame
                break
        if first_frame is None:
            raise RuntimeError("Failed to decode a frame after fast seek.")
        pts = first_frame.pts if first_frame.pts is not None else first_frame.dts
        img = first_frame.to_rgb().to_ndarray() if decode_rgb else first_frame.to_ndarray(format="bgr24")
        cur = DecodedFrame(
            image=img,
            pts=pts,
            time_s=self._frame_time_s(pts),
            key_frame=bool(getattr(first_frame, "key_frame", False)),
        )
        if pts is not None:
            self._frame_cache.put(int(pts), cur)
        return cur

    delta = 16
    attempts = 0
    while True:
        start_frame = max(target_frame - delta, 0)
        seek_to_frame(start_frame)
        decoder = self._fast_container.decode(self._fast_stream)
        try:
            frame = next(decoder)
        except StopIteration:
            break

        pts = frame.pts if frame.pts is not None else frame.dts
        frame_number = frame_number_from_pts(pts)
        if frame_number is None:
            frame_number = start_frame

        if frame_number &lt; 0 or frame_number &gt; target_frame:
            if start_frame == 0 or delta &gt;= 1 &lt;&lt; 30 or attempts &gt; 20:
                break
            delta = delta * 2 if delta &lt; 16 else int(delta * 1.5)
            attempts += 1
            continue

        while frame_number &lt; target_frame:
            try:
                frame = next(decoder)
            except StopIteration:
                frame = None
                break
            pts = frame.pts if frame.pts is not None else frame.dts
            frame_number = frame_number_from_pts(pts)
            if frame_number is None:
                frame_number = target_frame

        if frame is None:
            break

        pts = frame.pts if frame.pts is not None else frame.dts
        img = frame.to_rgb().to_ndarray() if decode_rgb else frame.to_ndarray(format="bgr24")
        cur = DecodedFrame(
            image=img,
            pts=pts,
            time_s=self._frame_time_s(pts),
            key_frame=bool(getattr(frame, "key_frame", False)),
        )
        if pts is not None:
            self._frame_cache.put(int(pts), cur)
        return cur

    target_pts = self._secs_to_pts(target_frame / fps)
    return self._read_frame_fast_simple(target_pts, decode_rgb=decode_rgb)</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="acvr._pyav_backend.PyAVVideoBackend._read_frame_fast_simple" class="doc doc-heading">
            <code class=" language-python">_read_frame_fast_simple(target_pts, *, decode_rgb)</code>

</h2>


    <div class="doc doc-contents ">

        <p>Fallback fast seek: seek and decode first frame after PTS.</p>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>acvr/_pyav_backend.py</code></summary>
              <pre class="codehilite"><code class="language-python">def _read_frame_fast_simple(self, target_pts: int, *, decode_rgb: bool) -&gt; DecodedFrame:
    """Fallback fast seek: seek and decode first frame after PTS."""

    self._ensure_fast_container()
    assert self._fast_container is not None
    assert self._fast_stream is not None

    def grab_frame(container: av.container.InputContainer, stream: av.video.stream.VideoStream) -&gt; Optional[DecodedFrame]:
        for frame in container.decode(stream):
            pts = frame.pts if frame.pts is not None else frame.dts
            if pts is None:
                target_reached = True
            else:
                target_reached = pts &gt;= target_pts
            if not target_reached:
                continue
            if decode_rgb:
                img = frame.to_rgb().to_ndarray()
            else:
                img = frame.to_ndarray(format="bgr24")
            cur = DecodedFrame(
                image=img,
                pts=pts,
                time_s=self._frame_time_s(pts),
                key_frame=bool(getattr(frame, "key_frame", False)),
            )
            if pts is not None:
                self._frame_cache.put(int(pts), cur)
            return cur
        return None

    self._fast_container.seek(
        target_pts,
        stream=self._fast_stream,
        backward=True,
        any_frame=True,
    )
    try:
        self._fast_stream.codec_context.flush_buffers()
    except Exception:
        pass
    grabbed = grab_frame(self._fast_container, self._fast_stream)
    if grabbed is not None:
        return grabbed

    self._fast_container.seek(
        target_pts,
        stream=self._fast_stream,
        backward=True,
        any_frame=False,
    )
    try:
        self._fast_stream.codec_context.flush_buffers()
    except Exception:
        pass
    grabbed = grab_frame(self._fast_container, self._fast_stream)
    if grabbed is not None:
        return grabbed

    raise RuntimeError("Failed to decode a frame after fast seek.")</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="acvr._pyav_backend.PyAVVideoBackend._secs_to_pts" class="doc doc-heading">
            <code class=" language-python">_secs_to_pts(t_s)</code>

</h2>


    <div class="doc doc-contents ">

        <p>Convert seconds to presentation timestamp units.</p>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>acvr/_pyav_backend.py</code></summary>
              <pre class="codehilite"><code class="language-python">def _secs_to_pts(self, t_s: float) -&gt; int:
    """Convert seconds to presentation timestamp units."""

    ticks = int(round(t_s / float(self._time_base)))
    return self._start_pts + ticks</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="acvr._pyav_backend.PyAVVideoBackend._seek_seq_to_pts" class="doc doc-heading">
            <code class=" language-python">_seek_seq_to_pts(target_pts, *, target_index, decode_rgb, any_frame=False)</code>

</h2>


    <div class="doc doc-contents ">

        <p>Seek the sequential decoder to a PTS and return the first match.</p>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>acvr/_pyav_backend.py</code></summary>
              <pre class="codehilite"><code class="language-python">def _seek_seq_to_pts(
    self,
    target_pts: int,
    *,
    target_index: int,
    decode_rgb: bool,
    any_frame: bool = False,
) -&gt; DecodedFrame:
    """Seek the sequential decoder to a PTS and return the first match."""

    self._ensure_seq_container()
    assert self._seq_container is not None
    assert self._seq_stream is not None

    seek_pts = target_pts
    if self._keyframes and not any_frame:
        idx = self._keyframe_index_at_or_before_pts(target_pts)
        seek_pts = self._keyframes[idx].pts

    self._seq_container.seek(
        seek_pts,
        stream=self._seq_stream,
        backward=True,
        any_frame=any_frame,
    )
    try:
        self._seq_stream.codec_context.flush_buffers()
    except Exception:
        pass

    decoder = self._seq_container.decode(self._seq_stream)
    last: Optional[DecodedFrame] = None
    for frame in decoder:
        pts = frame.pts if frame.pts is not None else frame.dts
        img = frame.to_rgb().to_ndarray() if decode_rgb else frame.to_ndarray(format="bgr24")
        cur = DecodedFrame(
            image=img,
            pts=pts,
            time_s=self._frame_time_s(pts),
            key_frame=bool(getattr(frame, "key_frame", False)),
        )
        if pts is not None:
            self._frame_cache.put(int(pts), cur)
        if pts is None:
            last = cur
            continue
        if pts &gt;= target_pts:
            self._seq_decoder = decoder
            self._seq_frame_index = target_index + 1
            self._current_frame_pos = float(target_index)
            return cur
        last = cur

    if last is not None:
        self._seq_decoder = decoder
        self._seq_frame_index = target_index + 1
        self._current_frame_pos = float(target_index)
        return last
    raise RuntimeError("Could not decode any frames after seeking.")</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="acvr._pyav_backend.PyAVVideoBackend._seek_to_pts" class="doc doc-heading">
            <code class=" language-python">_seek_to_pts(pts, *, backward)</code>

</h2>


    <div class="doc doc-contents ">

        <p>Seek to a timestamp in the stream.</p>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>acvr/_pyav_backend.py</code></summary>
              <pre class="codehilite"><code class="language-python">def _seek_to_pts(self, pts: int, *, backward: bool) -&gt; None:
    """Seek to a timestamp in the stream."""

    self._container.seek(pts, stream=self._stream, backward=backward, any_frame=False)
    self._flush_decoder()</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="acvr._pyav_backend.PyAVVideoBackend.build_keyframe_index" class="doc doc-heading">
            <code class=" language-python">build_keyframe_index(*, max_packets=None)</code>

</h2>


    <div class="doc doc-contents ">

        <p>Scan packets and store keyframe pts/time.</p>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>acvr/_pyav_backend.py</code></summary>
              <pre class="codehilite"><code class="language-python">def build_keyframe_index(self, *, max_packets: Optional[int] = None) -&gt; List[KeyframeEntry]:
    """Scan packets and store keyframe pts/time."""

    path = self._container.name
    idx_container = av.open(path)
    idx_stream = idx_container.streams.video[self._stream.index]

    key_pts: List[int] = []
    n = 0
    for packet in idx_container.demux(idx_stream):
        if packet.dts is None and packet.pts is None:
            continue
        if packet.is_keyframe:
            pts = packet.pts if packet.pts is not None else packet.dts
            if pts is not None:
                key_pts.append(int(pts))
        n += 1
        if max_packets is not None and n &gt;= max_packets:
            break

    idx_container.close()

    key_pts = sorted(set(key_pts))
    if not key_pts:
        key_pts = [self._start_pts]

    self._keyframes = [KeyframeEntry(pts=p, time_s=self._pts_to_secs(p)) for p in key_pts]
    self._index_built = True

    self._bucket_to_kfidx.clear()
    return self._keyframes</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="acvr._pyav_backend.PyAVVideoBackend.close" class="doc doc-heading">
            <code class=" language-python">close()</code>

</h2>


    <div class="doc doc-contents ">

        <p>Close the underlying PyAV container.</p>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>acvr/_pyav_backend.py</code></summary>
              <pre class="codehilite"><code class="language-python">def close(self) -&gt; None:
    """Close the underlying PyAV container."""

    self._container.close()
    if self._fast_container is not None:
        self._fast_container.close()
        self._fast_container = None
        self._fast_stream = None
        self._fast_decoder = None
        self._fast_last_pts = None
    self._fast_first_frame_number = None
    if self._seq_container is not None:
        self._seq_container.close()
        self._seq_container = None
        self._seq_stream = None
        self._seq_decoder = None
    self._seq_frame_index = 0
    self._last_index = None
    self._last_fast_index = None</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="acvr._pyav_backend.PyAVVideoBackend.frame_at_index" class="doc doc-heading">
            <code class=" language-python">frame_at_index(index)</code>

</h2>


    <div class="doc doc-contents ">

        <p>Return the decoded frame at a zero-based index.</p>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>acvr/_pyav_backend.py</code></summary>
              <pre class="codehilite"><code class="language-python">def frame_at_index(self, index: int) -&gt; np.ndarray:
    """Return the decoded frame at a zero-based index."""

    return self._read_frame_at_index(index, decode_rgb=True, use_sequential=True).image</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="acvr._pyav_backend.PyAVVideoBackend.index_from_pts" class="doc doc-heading">
            <code class=" language-python">index_from_pts(pts)</code>

</h2>


    <div class="doc doc-contents ">

        <p>Map a PTS value to the nearest frame index.</p>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>acvr/_pyav_backend.py</code></summary>
              <pre class="codehilite"><code class="language-python">def index_from_pts(self, pts: int) -&gt; int:
    """Map a PTS value to the nearest frame index."""

    self._ensure_frame_pts()
    assert self._frame_pts is not None
    fps = self._frame_pts
    if not fps:
        return 0
    lo, hi = 0, len(fps) - 1
    if pts &lt;= fps[0]:
        return 0
    if pts &gt;= fps[-1]:
        return hi
    while lo &lt;= hi:
        mid = (lo + hi) // 2
        m = fps[mid]
        if m == pts:
            return mid
        if m &lt; pts:
            lo = mid + 1
        else:
            hi = mid - 1
    # choose nearest between hi and lo
    if lo &gt;= len(fps):
        return hi
    if hi &lt; 0:
        return lo
    return lo if abs(fps[lo] - pts) &lt; abs(fps[hi] - pts) else hi</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="acvr._pyav_backend.PyAVVideoBackend.index_from_time" class="doc doc-heading">
            <code class=" language-python">index_from_time(t_s)</code>

</h2>


    <div class="doc doc-contents ">

        <p>Map a timestamp in seconds to the nearest frame index.</p>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>acvr/_pyav_backend.py</code></summary>
              <pre class="codehilite"><code class="language-python">def index_from_time(self, t_s: float) -&gt; int:
    """Map a timestamp in seconds to the nearest frame index."""

    pts = self._secs_to_pts(float(t_s))
    return self.index_from_pts(int(pts))</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="acvr._pyav_backend.PyAVVideoBackend.iter_frames" class="doc doc-heading">
            <code class=" language-python">iter_frames(*, decode_rgb=True)</code>

</h2>


    <div class="doc doc-contents ">

        <p>Iterate through frames sequentially.</p>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>acvr/_pyav_backend.py</code></summary>
              <pre class="codehilite"><code class="language-python">def iter_frames(self, *, decode_rgb: bool = True) -&gt; Iterator[DecodedFrame]:
    """Iterate through frames sequentially."""

    self.reset_sequence()
    assert self._seq_decoder is not None
    for frame in self._seq_decoder:
        pts = frame.pts if frame.pts is not None else frame.dts
        img = frame.to_rgb().to_ndarray() if decode_rgb else frame.to_ndarray(format="bgr24")
        cur = DecodedFrame(
            image=img,
            pts=pts,
            time_s=self._frame_time_s(pts),
            key_frame=bool(getattr(frame, "key_frame", False)),
        )
        if pts is not None:
            self._frame_cache.put(int(pts), cur)
        self._current_frame_pos = float(self._seq_frame_index)
        self._seq_frame_index += 1
        yield cur</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="acvr._pyav_backend.PyAVVideoBackend.pts_at_index" class="doc doc-heading">
            <code class=" language-python">pts_at_index(index)</code>

</h2>


    <div class="doc doc-contents ">

        <p>Return the presentation timestamp (PTS) for a frame index.</p>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>acvr/_pyav_backend.py</code></summary>
              <pre class="codehilite"><code class="language-python">def pts_at_index(self, index: int) -&gt; Optional[int]:
    """Return the presentation timestamp (PTS) for a frame index."""

    self._ensure_frame_pts()
    assert self._frame_pts is not None
    if index &lt; 0:
        index += self._frame_count
    if index &lt; 0 or index &gt;= self._frame_count:
        raise IndexError("frame index out of range")
    return int(self._frame_pts[index])</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="acvr._pyav_backend.PyAVVideoBackend.read_frame" class="doc doc-heading">
            <code class=" language-python">read_frame(*, index=None, t_s=None, mode='accurate', decode_rgb=True, keyframe_mode='nearest', use_sequential=True)</code>

</h2>


    <div class="doc doc-contents ">

        <p>Read a frame using a selectable access mode.</p>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>acvr/_pyav_backend.py</code></summary>
              <pre class="codehilite"><code class="language-python">def read_frame(
    self,
    *,
    index: Optional[int] = None,
    t_s: Optional[Number] = None,
    mode: str = "accurate",
    decode_rgb: bool = True,
    keyframe_mode: str = "nearest",
    use_sequential: bool = True,
) -&gt; DecodedFrame:
    """Read a frame using a selectable access mode."""

    if mode not in {"accurate", "accurate_timeline", "fast", "scrub"}:
        raise ValueError("mode must be one of: 'accurate', 'accurate_timeline', 'fast', 'scrub'")
    if index is None and t_s is None:
        raise ValueError("Provide either index or t_s")
    if index is not None and t_s is not None:
        raise ValueError("Provide only one of index or t_s")

    if mode == "accurate":
        if index is not None:
            return self._read_frame_at_index(
                int(index),
                decode_rgb=decode_rgb,
                use_sequential=use_sequential,
            )
        assert t_s is not None
        return self.read_frame_at(float(t_s), use_index=False)

    if mode == "accurate_timeline":
        if t_s is None:
            fps = self._nominal_frame_rate or self._frame_rate or 1.0
            t_s = float(index) / fps
        return self.read_frame_at(float(t_s))

    if mode == "scrub":
        if t_s is None:
            fps = self._frame_rate or 1.0
            t_s = float(index) / fps
        return self.read_keyframe_at(float(t_s), mode=keyframe_mode, decode_rgb=decode_rgb)

    return self.read_frame_fast(
        index=index,
        t_s=t_s,
        decode_rgb=decode_rgb,
        use_sequential=use_sequential,
    )</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="acvr._pyav_backend.PyAVVideoBackend.read_frame_at" class="doc doc-heading">
            <code class=" language-python">read_frame_at(t_s, *, return_first_after=True, max_decode_frames=10000, use_index=True)</code>

</h2>


    <div class="doc doc-contents ">

        <p>Decode a frame near a timestamp with accurate seeking.</p>
<p>Simplified and robust: always uses a fresh container and backward keyframe seek.</p>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>acvr/_pyav_backend.py</code></summary>
              <pre class="codehilite"><code class="language-python">def read_frame_at(
    self,
    t_s: Number,
    *,
    return_first_after: bool = True,
    max_decode_frames: int = 10_000,
    use_index: bool = True,
) -&gt; DecodedFrame:
    """Decode a frame near a timestamp with accurate seeking.

    Simplified and robust: always uses a fresh container and backward keyframe seek.
    """

    t_s = float(t_s)
    target_pts = self._secs_to_pts(t_s)

    cached = self._frame_cache.get(target_pts)
    if cached is not None:
        return cached  # type: ignore[return-value]

    container = av.open(self._path)
    try:
        stream = container.streams.video[self._stream.index]
        self._configure_codec_context(stream)
        if use_index and self._index_built:
            idx = self._keyframe_index_at_or_before_pts(target_pts)
            anchor_pts = self._keyframes[idx].pts
            container.seek(anchor_pts, stream=stream, backward=True, any_frame=False)
        else:
            container.seek(target_pts, stream=stream, backward=True, any_frame=False)
        try:
            stream.codec_context.flush_buffers()
        except Exception:
            pass

        last: Optional[DecodedFrame] = None
        decoded = 0
        for packet in container.demux(stream):
            for frame in packet.decode():
                decoded += 1
                if decoded &gt; max_decode_frames:
                    raise RuntimeError(
                        "Exceeded max_decode_frames while seeking; timestamps may be broken."
                    )
                pts = frame.pts
                cur = DecodedFrame(
                    image=frame.to_rgb().to_ndarray(),
                    pts=pts,
                    time_s=self._frame_time_s(pts),
                    key_frame=bool(getattr(frame, "key_frame", False)),
                )
                if pts is not None:
                    self._frame_cache.put(int(pts), cur)
                if pts is None:
                    last = cur
                    continue
                if return_first_after:
                    if pts &gt;= target_pts:
                        return cur
                    last = cur
                else:
                    if pts &lt;= target_pts:
                        last = cur
                    elif last is not None:
                        return last
        if last is not None:
            return last
        raise RuntimeError("Could not decode any frames after seeking.")
    finally:
        container.close()</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="acvr._pyav_backend.PyAVVideoBackend.read_frame_fast" class="doc doc-heading">
            <code class=" language-python">read_frame_fast(*, index=None, t_s=None, decode_rgb=True, use_sequential=True)</code>

</h2>


    <div class="doc doc-contents ">

        <p>Return a fast, approximate frame for an index or timestamp.</p>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>acvr/_pyav_backend.py</code></summary>
              <pre class="codehilite"><code class="language-python">def read_frame_fast(
    self,
    *,
    index: Optional[int] = None,
    t_s: Optional[Number] = None,
    decode_rgb: bool = True,
    use_sequential: bool = True,
) -&gt; DecodedFrame:
    """Return a fast, approximate frame for an index or timestamp."""

    if index is None and t_s is None:
        raise ValueError("Provide either index or t_s")
    if index is not None and t_s is not None:
        raise ValueError("Provide only one of index or t_s")

    if t_s is None:
        if index is None:
            raise ValueError("Provide either index or t_s")
        if index &lt; 0:
            index += self.number_of_frames
        target_frame = int(index)
    else:
        t_s = float(t_s)
        target_frame = int(round(t_s * (self._nominal_frame_rate or self._frame_rate or 1.0)))

    if use_sequential:
        decoded = self._read_frame_fast_like(target_frame, decode_rgb=decode_rgb)
        self._last_fast_index = target_frame
        return decoded

    fps = self._nominal_frame_rate or self._frame_rate or 1.0
    target_pts = self._secs_to_pts(target_frame / fps)
    cached = self._frame_cache.get(target_pts)
    if cached is not None:
        self._last_fast_index = target_frame
        return cached  # type: ignore[return-value]

    decoded = self._read_frame_fast_opencv_pyav(target_frame, decode_rgb=decode_rgb)
    self._last_fast_index = target_frame
    return decoded</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="acvr._pyav_backend.PyAVVideoBackend.read_keyframe_at" class="doc doc-heading">
            <code class=" language-python">read_keyframe_at(t_s, *, mode='nearest', decode_rgb=True)</code>

</h2>


    <div class="doc doc-contents ">

        <p>Return a nearby keyframe without GOP forward decoding.</p>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>acvr/_pyav_backend.py</code></summary>
              <pre class="codehilite"><code class="language-python">def read_keyframe_at(
    self,
    t_s: Number,
    *,
    mode: str = "nearest",
    decode_rgb: bool = True,
) -&gt; DecodedFrame:
    """Return a nearby keyframe without GOP forward decoding."""

    t_s = float(t_s)
    idx = self._keyframe_index_for_time_fast(t_s, mode)
    key_pts = self._keyframes[idx].pts

    cached = self._frame_cache.get(key_pts)
    if cached is not None:
        return cached  # type: ignore[return-value]

    # Use a fresh container for reliable keyframe seek, avoiding stateful issues
    container = av.open(self._path)
    try:
        stream = container.streams.video[self._stream.index]
        self._configure_codec_context(stream)
        # Use backward seek to land on or before the requested keyframe PTS reliably
        container.seek(key_pts, stream=stream, backward=True, any_frame=False)
        try:
            stream.codec_context.flush_buffers()
        except Exception:
            pass

        for packet in container.demux(stream):
            for frame in packet.decode():
                pts = frame.pts
                img = frame.to_rgb().to_ndarray() if decode_rgb else frame.to_ndarray()
                cur = DecodedFrame(
                    image=img,
                    pts=pts,
                    time_s=self._frame_time_s(pts),
                    key_frame=bool(getattr(frame, "key_frame", False)),
                )
                if pts is not None:
                    self._frame_cache.put(int(pts), cur)
                return cur
    finally:
        container.close()

    raise RuntimeError("Failed to decode a frame after keyframe seek.")</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="acvr._pyav_backend.PyAVVideoBackend.read_next_frame" class="doc doc-heading">
            <code class=" language-python">read_next_frame(*, decode_rgb=True)</code>

</h2>


    <div class="doc doc-contents ">

        <p>Return the next frame using sequential decoding.</p>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>acvr/_pyav_backend.py</code></summary>
              <pre class="codehilite"><code class="language-python">def read_next_frame(self, *, decode_rgb: bool = True) -&gt; DecodedFrame:
    """Return the next frame using sequential decoding."""

    self._ensure_seq_container()
    assert self._seq_decoder is not None
    try:
        frame = next(self._seq_decoder)
    except StopIteration:
        raise
    pts = frame.pts if frame.pts is not None else frame.dts
    img = frame.to_rgb().to_ndarray() if decode_rgb else frame.to_ndarray(format="bgr24")
    cur = DecodedFrame(
        image=img,
        pts=pts,
        time_s=self._frame_time_s(pts),
        key_frame=bool(getattr(frame, "key_frame", False)),
    )
    if pts is not None:
        self._frame_cache.put(int(pts), cur)
    self._current_frame_pos = float(self._seq_frame_index)
    self._last_index = int(self._seq_frame_index)
    self._last_fast_index = int(self._seq_frame_index)
    self._seq_frame_index += 1
    return cur</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="acvr._pyav_backend.PyAVVideoBackend.reset_sequence" class="doc doc-heading">
            <code class=" language-python">reset_sequence()</code>

</h2>


    <div class="doc doc-contents ">

        <p>Reset sequential decoding to the first frame.</p>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>acvr/_pyav_backend.py</code></summary>
              <pre class="codehilite"><code class="language-python">def reset_sequence(self) -&gt; None:
    """Reset sequential decoding to the first frame."""

    self._ensure_seq_container()
    assert self._seq_container is not None
    assert self._seq_stream is not None
    try:
        self._seq_container.seek(0)
    except Exception:
        pass
    self._seq_decoder = self._seq_container.decode(self._seq_stream)
    self._seq_frame_index = 0</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="acvr._pyav_backend.PyAVVideoBackend.time_at_index" class="doc doc-heading">
            <code class=" language-python">time_at_index(index)</code>

</h2>


    <div class="doc doc-contents ">

        <p>Return the timestamp in seconds for a frame index.</p>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>acvr/_pyav_backend.py</code></summary>
              <pre class="codehilite"><code class="language-python">def time_at_index(self, index: int) -&gt; float:
    """Return the timestamp in seconds for a frame index."""

    pts = self.pts_at_index(index)
    return float("nan") if pts is None else self._pts_to_secs(int(pts))</code></pre>
            </details>
    </div>

</div>



  </div>

    </div>

</div>
  </div>
</article>
                                <div class="mx-auto flex flex-wrap h-16 w-full max-w-2xl items-center gap-2 px-4 md:px-0">
    
    <a data-slot="button"
        class="inline-flex items-center justify-center whitespace-nowrap text-sm font-medium transition-all disabled:pointer-events-none disabled:opacity-50 [&amp;_svg]:pointer-events-none [&amp;_svg:not([class*='size-'])]:size-4 shrink-0 [&amp;_svg]:shrink-0 outline-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive bg-secondary text-secondary-foreground hover:bg-secondary/80 h-8 rounded-md gap-1.5 px-3 has-[&gt;svg]:px-2.5 shadow-none"
        href="/acvr/benchmark/">
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none"
            stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"
            class="tabler-icon tabler-icon-arrow-left ">
            <path d="M5 12l14 0"></path>
            <path d="M5 12l6 6"></path>
            <path d="M5 12l6 -6"></path>
        </svg>
        <span class="max-[500px]:hidden">Benchmarking</span>
    </a>
    
    
</div>
                                <dialog id="bottom-sidebar" onclick="onBottomSidebarDialogClick(event)" class="bg-transparent"
    style="position: fixed; left: 0px; top: 0px; transform: translate(0px, 58px); min-width: max-content; --radix-popper-transform-origin: 0% 0px; will-change: transform; z-index: 50; --radix-popper-available-width: 504px; --radix-popper-available-height: 857px; --radix-popper-anchor-width: 72.94999694824219px; --radix-popper-anchor-height: 32px;">
    <div data-side="bottom" data-align="start" data-state="open" role="dialog" data-slot="popover-content"
        class="text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 origin-(--radix-popover-content-transform-origin) border outline-hidden bg-background/90 no-scrollbar h-(--radix-popper-available-height) w-(--radix-popper-available-width) overflow-y-auto rounded-none border-none p-0 shadow-none backdrop-blur duration-100"
        style="--radix-popover-content-transform-origin: var(--radix-popper-transform-origin); --radix-popover-content-available-width: var(--radix-popper-available-width); --radix-popover-content-available-height: var(--radix-popper-available-height); --radix-popover-trigger-width: var(--radix-popper-anchor-width); --radix-popover-trigger-height: var(--radix-popper-anchor-height);"
        tabindex="-1">
        <div class="flex flex-col gap-12 overflow-auto px-6 py-6">
            
            
            

            
            <div class="flex flex-col gap-4">
                <div class="text-muted-foreground text-sm font-medium">Menu</div>
                <div class="flex flex-col gap-3">
                    
                    <a class="text-2xl font-medium" href="..">
                        
                        Home
                        
                    </a>
                    
                    <a class="text-2xl font-medium" href="../usage/">
                        
                        Usage
                        
                    </a>
                    
                    <a class="text-2xl font-medium" href="../indexing/">
                        
                        Indexing & Modes
                        
                    </a>
                    
                    <a class="text-2xl font-medium" href="../technical/">
                        
                        Technical
                        
                    </a>
                    
                    <a class="text-2xl font-medium" href="../benchmark/">
                        
                        Benchmarking
                        
                    </a>
                    
                    <a class="text-2xl font-medium" href="./">
                        
                        API
                        
                    </a>
                    
                </div>
            </div>
            

            
            

        </div>
    </div>
</dialog>
                            </div>
                            <div
                                class="sticky top-[calc(var(--header-height)+1px)] z-30 ml-auto hidden h-[calc(100svh-var(--header-height)-var(--footer-height))] w-72 flex-col gap-4 overflow-hidden overscroll-none pb-8 xl:flex">
                                <div class="h-(--top-spacing) shrink-0"></div>
                                <div view-transition-name="toc" class="no-scrollbar overflow-y-auto px-8">
    <div class="flex flex-col gap-2 p-4 pt-0 text-sm">
        <p class="text-muted-foreground bg-background sticky top-0 h-6 text-xs">On This Page</p>
        
        
        
        
        <a href="#videoreader"
            class="text-muted-foreground hover:text-foreground data-[active=true]:text-foreground text-[0.8rem] no-underline transition-colors data-[depth=3]:pl-4 data-[depth=4]:pl-6"
            data-active="false" data-depth="2">
            VideoReader
        </a>
        

        
        <a href="#acvr.reader.VideoReader"
            class="text-muted-foreground hover:text-foreground data-[active=true]:text-foreground text-[0.8rem] no-underline transition-colors data-[depth=3]:pl-4 data-[depth=4]:pl-6"
            data-active="false" data-depth="2">
            VideoReader
        </a>
        

        
        <a href="#acvr.reader.VideoReader._backend"
            class="text-muted-foreground hover:text-foreground data-[active=true]:text-foreground text-[0.8rem] no-underline transition-colors data-[depth=3]:pl-4 data-[depth=4]:pl-6"
            data-active="false" data-depth="2">
            _backend
        </a>
        

        
        <a href="#acvr.reader.VideoReader._index_policy"
            class="text-muted-foreground hover:text-foreground data-[active=true]:text-foreground text-[0.8rem] no-underline transition-colors data-[depth=3]:pl-4 data-[depth=4]:pl-6"
            data-active="false" data-depth="2">
            _index_policy
        </a>
        

        
        <a href="#acvr.reader.VideoReader.current_frame_pos"
            class="text-muted-foreground hover:text-foreground data-[active=true]:text-foreground text-[0.8rem] no-underline transition-colors data-[depth=3]:pl-4 data-[depth=4]:pl-6"
            data-active="false" data-depth="2">
            current_frame_pos
        </a>
        

        
        <a href="#acvr.reader.VideoReader.fourcc"
            class="text-muted-foreground hover:text-foreground data-[active=true]:text-foreground text-[0.8rem] no-underline transition-colors data-[depth=3]:pl-4 data-[depth=4]:pl-6"
            data-active="false" data-depth="2">
            fourcc
        </a>
        

        
        <a href="#acvr.reader.VideoReader.frame_format"
            class="text-muted-foreground hover:text-foreground data-[active=true]:text-foreground text-[0.8rem] no-underline transition-colors data-[depth=3]:pl-4 data-[depth=4]:pl-6"
            data-active="false" data-depth="2">
            frame_format
        </a>
        

        
        <a href="#acvr.reader.VideoReader.frame_height"
            class="text-muted-foreground hover:text-foreground data-[active=true]:text-foreground text-[0.8rem] no-underline transition-colors data-[depth=3]:pl-4 data-[depth=4]:pl-6"
            data-active="false" data-depth="2">
            frame_height
        </a>
        

        
        <a href="#acvr.reader.VideoReader.frame_rate"
            class="text-muted-foreground hover:text-foreground data-[active=true]:text-foreground text-[0.8rem] no-underline transition-colors data-[depth=3]:pl-4 data-[depth=4]:pl-6"
            data-active="false" data-depth="2">
            frame_rate
        </a>
        

        
        <a href="#acvr.reader.VideoReader.frame_shape"
            class="text-muted-foreground hover:text-foreground data-[active=true]:text-foreground text-[0.8rem] no-underline transition-colors data-[depth=3]:pl-4 data-[depth=4]:pl-6"
            data-active="false" data-depth="2">
            frame_shape
        </a>
        

        
        <a href="#acvr.reader.VideoReader.frame_width"
            class="text-muted-foreground hover:text-foreground data-[active=true]:text-foreground text-[0.8rem] no-underline transition-colors data-[depth=3]:pl-4 data-[depth=4]:pl-6"
            data-active="false" data-depth="2">
            frame_width
        </a>
        

        
        <a href="#acvr.reader.VideoReader.nominal_frame_rate"
            class="text-muted-foreground hover:text-foreground data-[active=true]:text-foreground text-[0.8rem] no-underline transition-colors data-[depth=3]:pl-4 data-[depth=4]:pl-6"
            data-active="false" data-depth="2">
            nominal_frame_rate
        </a>
        

        
        <a href="#acvr.reader.VideoReader.number_of_frames"
            class="text-muted-foreground hover:text-foreground data-[active=true]:text-foreground text-[0.8rem] no-underline transition-colors data-[depth=3]:pl-4 data-[depth=4]:pl-6"
            data-active="false" data-depth="2">
            number_of_frames
        </a>
        

        
        <a href="#acvr.reader.VideoReader.__enter__"
            class="text-muted-foreground hover:text-foreground data-[active=true]:text-foreground text-[0.8rem] no-underline transition-colors data-[depth=3]:pl-4 data-[depth=4]:pl-6"
            data-active="false" data-depth="2">
            __enter__
        </a>
        

        
        <a href="#acvr.reader.VideoReader.__exit__"
            class="text-muted-foreground hover:text-foreground data-[active=true]:text-foreground text-[0.8rem] no-underline transition-colors data-[depth=3]:pl-4 data-[depth=4]:pl-6"
            data-active="false" data-depth="2">
            __exit__
        </a>
        

        
        <a href="#acvr.reader.VideoReader.__getitem__"
            class="text-muted-foreground hover:text-foreground data-[active=true]:text-foreground text-[0.8rem] no-underline transition-colors data-[depth=3]:pl-4 data-[depth=4]:pl-6"
            data-active="false" data-depth="2">
            __getitem__
        </a>
        

        
        <a href="#acvr.reader.VideoReader.__init__"
            class="text-muted-foreground hover:text-foreground data-[active=true]:text-foreground text-[0.8rem] no-underline transition-colors data-[depth=3]:pl-4 data-[depth=4]:pl-6"
            data-active="false" data-depth="2">
            __init__
        </a>
        

        
        <a href="#acvr.reader.VideoReader.__iter__"
            class="text-muted-foreground hover:text-foreground data-[active=true]:text-foreground text-[0.8rem] no-underline transition-colors data-[depth=3]:pl-4 data-[depth=4]:pl-6"
            data-active="false" data-depth="2">
            __iter__
        </a>
        

        
        <a href="#acvr.reader.VideoReader.__len__"
            class="text-muted-foreground hover:text-foreground data-[active=true]:text-foreground text-[0.8rem] no-underline transition-colors data-[depth=3]:pl-4 data-[depth=4]:pl-6"
            data-active="false" data-depth="2">
            __len__
        </a>
        

        
        <a href="#acvr.reader.VideoReader.build_keyframe_index"
            class="text-muted-foreground hover:text-foreground data-[active=true]:text-foreground text-[0.8rem] no-underline transition-colors data-[depth=3]:pl-4 data-[depth=4]:pl-6"
            data-active="false" data-depth="2">
            build_keyframe_index
        </a>
        

        
        <a href="#acvr.reader.VideoReader.close"
            class="text-muted-foreground hover:text-foreground data-[active=true]:text-foreground text-[0.8rem] no-underline transition-colors data-[depth=3]:pl-4 data-[depth=4]:pl-6"
            data-active="false" data-depth="2">
            close
        </a>
        

        
        <a href="#acvr.reader.VideoReader.index_from_pts"
            class="text-muted-foreground hover:text-foreground data-[active=true]:text-foreground text-[0.8rem] no-underline transition-colors data-[depth=3]:pl-4 data-[depth=4]:pl-6"
            data-active="false" data-depth="2">
            index_from_pts
        </a>
        

        
        <a href="#acvr.reader.VideoReader.index_from_time"
            class="text-muted-foreground hover:text-foreground data-[active=true]:text-foreground text-[0.8rem] no-underline transition-colors data-[depth=3]:pl-4 data-[depth=4]:pl-6"
            data-active="false" data-depth="2">
            index_from_time
        </a>
        

        
        <a href="#acvr.reader.VideoReader.iter_frames"
            class="text-muted-foreground hover:text-foreground data-[active=true]:text-foreground text-[0.8rem] no-underline transition-colors data-[depth=3]:pl-4 data-[depth=4]:pl-6"
            data-active="false" data-depth="2">
            iter_frames
        </a>
        

        
        <a href="#acvr.reader.VideoReader.pts_at_index"
            class="text-muted-foreground hover:text-foreground data-[active=true]:text-foreground text-[0.8rem] no-underline transition-colors data-[depth=3]:pl-4 data-[depth=4]:pl-6"
            data-active="false" data-depth="2">
            pts_at_index
        </a>
        

        
        <a href="#acvr.reader.VideoReader.read_frame"
            class="text-muted-foreground hover:text-foreground data-[active=true]:text-foreground text-[0.8rem] no-underline transition-colors data-[depth=3]:pl-4 data-[depth=4]:pl-6"
            data-active="false" data-depth="2">
            read_frame
        </a>
        

        
        <a href="#acvr.reader.VideoReader.read_frame_at"
            class="text-muted-foreground hover:text-foreground data-[active=true]:text-foreground text-[0.8rem] no-underline transition-colors data-[depth=3]:pl-4 data-[depth=4]:pl-6"
            data-active="false" data-depth="2">
            read_frame_at
        </a>
        

        
        <a href="#acvr.reader.VideoReader.read_frame_fast"
            class="text-muted-foreground hover:text-foreground data-[active=true]:text-foreground text-[0.8rem] no-underline transition-colors data-[depth=3]:pl-4 data-[depth=4]:pl-6"
            data-active="false" data-depth="2">
            read_frame_fast
        </a>
        

        
        <a href="#acvr.reader.VideoReader.read_keyframe_at"
            class="text-muted-foreground hover:text-foreground data-[active=true]:text-foreground text-[0.8rem] no-underline transition-colors data-[depth=3]:pl-4 data-[depth=4]:pl-6"
            data-active="false" data-depth="2">
            read_keyframe_at
        </a>
        

        
        <a href="#acvr.reader.VideoReader.read_next"
            class="text-muted-foreground hover:text-foreground data-[active=true]:text-foreground text-[0.8rem] no-underline transition-colors data-[depth=3]:pl-4 data-[depth=4]:pl-6"
            data-active="false" data-depth="2">
            read_next
        </a>
        

        
        <a href="#acvr.reader.VideoReader.time_at_index"
            class="text-muted-foreground hover:text-foreground data-[active=true]:text-foreground text-[0.8rem] no-underline transition-colors data-[depth=3]:pl-4 data-[depth=4]:pl-6"
            data-active="false" data-depth="2">
            time_at_index
        </a>
        

        
        <a href="#backend-implementation"
            class="text-muted-foreground hover:text-foreground data-[active=true]:text-foreground text-[0.8rem] no-underline transition-colors data-[depth=3]:pl-4 data-[depth=4]:pl-6"
            data-active="false" data-depth="2">
            Backend implementation
        </a>
        

        
        <a href="#acvr._pyav_backend.PyAVVideoBackend"
            class="text-muted-foreground hover:text-foreground data-[active=true]:text-foreground text-[0.8rem] no-underline transition-colors data-[depth=3]:pl-4 data-[depth=4]:pl-6"
            data-active="false" data-depth="2">
            PyAVVideoBackend
        </a>
        

        
        <a href="#acvr._pyav_backend.PyAVVideoBackend._bucket_to_kfidx"
            class="text-muted-foreground hover:text-foreground data-[active=true]:text-foreground text-[0.8rem] no-underline transition-colors data-[depth=3]:pl-4 data-[depth=4]:pl-6"
            data-active="false" data-depth="2">
            _bucket_to_kfidx
        </a>
        

        
        <a href="#acvr._pyav_backend.PyAVVideoBackend._codec_ctx"
            class="text-muted-foreground hover:text-foreground data-[active=true]:text-foreground text-[0.8rem] no-underline transition-colors data-[depth=3]:pl-4 data-[depth=4]:pl-6"
            data-active="false" data-depth="2">
            _codec_ctx
        </a>
        

        
        <a href="#acvr._pyav_backend.PyAVVideoBackend._container"
            class="text-muted-foreground hover:text-foreground data-[active=true]:text-foreground text-[0.8rem] no-underline transition-colors data-[depth=3]:pl-4 data-[depth=4]:pl-6"
            data-active="false" data-depth="2">
            _container
        </a>
        

        
        <a href="#acvr._pyav_backend.PyAVVideoBackend._current_frame_pos"
            class="text-muted-foreground hover:text-foreground data-[active=true]:text-foreground text-[0.8rem] no-underline transition-colors data-[depth=3]:pl-4 data-[depth=4]:pl-6"
            data-active="false" data-depth="2">
            _current_frame_pos
        </a>
        

        
        <a href="#acvr._pyav_backend.PyAVVideoBackend._fast_container"
            class="text-muted-foreground hover:text-foreground data-[active=true]:text-foreground text-[0.8rem] no-underline transition-colors data-[depth=3]:pl-4 data-[depth=4]:pl-6"
            data-active="false" data-depth="2">
            _fast_container
        </a>
        

        
        <a href="#acvr._pyav_backend.PyAVVideoBackend._fast_decoder"
            class="text-muted-foreground hover:text-foreground data-[active=true]:text-foreground text-[0.8rem] no-underline transition-colors data-[depth=3]:pl-4 data-[depth=4]:pl-6"
            data-active="false" data-depth="2">
            _fast_decoder
        </a>
        

        
        <a href="#acvr._pyav_backend.PyAVVideoBackend._fast_first_frame_number"
            class="text-muted-foreground hover:text-foreground data-[active=true]:text-foreground text-[0.8rem] no-underline transition-colors data-[depth=3]:pl-4 data-[depth=4]:pl-6"
            data-active="false" data-depth="2">
            _fast_first_frame_number
        </a>
        

        
        <a href="#acvr._pyav_backend.PyAVVideoBackend._fast_last_pts"
            class="text-muted-foreground hover:text-foreground data-[active=true]:text-foreground text-[0.8rem] no-underline transition-colors data-[depth=3]:pl-4 data-[depth=4]:pl-6"
            data-active="false" data-depth="2">
            _fast_last_pts
        </a>
        

        
        <a href="#acvr._pyav_backend.PyAVVideoBackend._fast_stream"
            class="text-muted-foreground hover:text-foreground data-[active=true]:text-foreground text-[0.8rem] no-underline transition-colors data-[depth=3]:pl-4 data-[depth=4]:pl-6"
            data-active="false" data-depth="2">
            _fast_stream
        </a>
        

        
        <a href="#acvr._pyav_backend.PyAVVideoBackend._fourcc"
            class="text-muted-foreground hover:text-foreground data-[active=true]:text-foreground text-[0.8rem] no-underline transition-colors data-[depth=3]:pl-4 data-[depth=4]:pl-6"
            data-active="false" data-depth="2">
            _fourcc
        </a>
        

        
        <a href="#acvr._pyav_backend.PyAVVideoBackend._frame_cache"
            class="text-muted-foreground hover:text-foreground data-[active=true]:text-foreground text-[0.8rem] no-underline transition-colors data-[depth=3]:pl-4 data-[depth=4]:pl-6"
            data-active="false" data-depth="2">
            _frame_cache
        </a>
        

        
        <a href="#acvr._pyav_backend.PyAVVideoBackend._frame_count"
            class="text-muted-foreground hover:text-foreground data-[active=true]:text-foreground text-[0.8rem] no-underline transition-colors data-[depth=3]:pl-4 data-[depth=4]:pl-6"
            data-active="false" data-depth="2">
            _frame_count
        </a>
        

        
        <a href="#acvr._pyav_backend.PyAVVideoBackend._frame_format"
            class="text-muted-foreground hover:text-foreground data-[active=true]:text-foreground text-[0.8rem] no-underline transition-colors data-[depth=3]:pl-4 data-[depth=4]:pl-6"
            data-active="false" data-depth="2">
            _frame_format
        </a>
        

        
        <a href="#acvr._pyav_backend.PyAVVideoBackend._frame_height"
            class="text-muted-foreground hover:text-foreground data-[active=true]:text-foreground text-[0.8rem] no-underline transition-colors data-[depth=3]:pl-4 data-[depth=4]:pl-6"
            data-active="false" data-depth="2">
            _frame_height
        </a>
        

        
        <a href="#acvr._pyav_backend.PyAVVideoBackend._frame_pts"
            class="text-muted-foreground hover:text-foreground data-[active=true]:text-foreground text-[0.8rem] no-underline transition-colors data-[depth=3]:pl-4 data-[depth=4]:pl-6"
            data-active="false" data-depth="2">
            _frame_pts
        </a>
        

        
        <a href="#acvr._pyav_backend.PyAVVideoBackend._frame_rate"
            class="text-muted-foreground hover:text-foreground data-[active=true]:text-foreground text-[0.8rem] no-underline transition-colors data-[depth=3]:pl-4 data-[depth=4]:pl-6"
            data-active="false" data-depth="2">
            _frame_rate
        </a>
        

        
        <a href="#acvr._pyav_backend.PyAVVideoBackend._frame_shape"
            class="text-muted-foreground hover:text-foreground data-[active=true]:text-foreground text-[0.8rem] no-underline transition-colors data-[depth=3]:pl-4 data-[depth=4]:pl-6"
            data-active="false" data-depth="2">
            _frame_shape
        </a>
        

        
        <a href="#acvr._pyav_backend.PyAVVideoBackend._frame_width"
            class="text-muted-foreground hover:text-foreground data-[active=true]:text-foreground text-[0.8rem] no-underline transition-colors data-[depth=3]:pl-4 data-[depth=4]:pl-6"
            data-active="false" data-depth="2">
            _frame_width
        </a>
        

        
        <a href="#acvr._pyav_backend.PyAVVideoBackend._index_built"
            class="text-muted-foreground hover:text-foreground data-[active=true]:text-foreground text-[0.8rem] no-underline transition-colors data-[depth=3]:pl-4 data-[depth=4]:pl-6"
            data-active="false" data-depth="2">
            _index_built
        </a>
        

        
        <a href="#acvr._pyav_backend.PyAVVideoBackend._keyframes"
            class="text-muted-foreground hover:text-foreground data-[active=true]:text-foreground text-[0.8rem] no-underline transition-colors data-[depth=3]:pl-4 data-[depth=4]:pl-6"
            data-active="false" data-depth="2">
            _keyframes
        </a>
        

        
        <a href="#acvr._pyav_backend.PyAVVideoBackend._last_fast_index"
            class="text-muted-foreground hover:text-foreground data-[active=true]:text-foreground text-[0.8rem] no-underline transition-colors data-[depth=3]:pl-4 data-[depth=4]:pl-6"
            data-active="false" data-depth="2">
            _last_fast_index
        </a>
        

        
        <a href="#acvr._pyav_backend.PyAVVideoBackend._last_index"
            class="text-muted-foreground hover:text-foreground data-[active=true]:text-foreground text-[0.8rem] no-underline transition-colors data-[depth=3]:pl-4 data-[depth=4]:pl-6"
            data-active="false" data-depth="2">
            _last_index
        </a>
        

        
        <a href="#acvr._pyav_backend.PyAVVideoBackend._nominal_frame_rate"
            class="text-muted-foreground hover:text-foreground data-[active=true]:text-foreground text-[0.8rem] no-underline transition-colors data-[depth=3]:pl-4 data-[depth=4]:pl-6"
            data-active="false" data-depth="2">
            _nominal_frame_rate
        </a>
        

        
        <a href="#acvr._pyav_backend.PyAVVideoBackend._path"
            class="text-muted-foreground hover:text-foreground data-[active=true]:text-foreground text-[0.8rem] no-underline transition-colors data-[depth=3]:pl-4 data-[depth=4]:pl-6"
            data-active="false" data-depth="2">
            _path
        </a>
        

        
        <a href="#acvr._pyav_backend.PyAVVideoBackend._scrub_bucket_ms"
            class="text-muted-foreground hover:text-foreground data-[active=true]:text-foreground text-[0.8rem] no-underline transition-colors data-[depth=3]:pl-4 data-[depth=4]:pl-6"
            data-active="false" data-depth="2">
            _scrub_bucket_ms
        </a>
        

        
        <a href="#acvr._pyav_backend.PyAVVideoBackend._seq_container"
            class="text-muted-foreground hover:text-foreground data-[active=true]:text-foreground text-[0.8rem] no-underline transition-colors data-[depth=3]:pl-4 data-[depth=4]:pl-6"
            data-active="false" data-depth="2">
            _seq_container
        </a>
        

        
        <a href="#acvr._pyav_backend.PyAVVideoBackend._seq_decoder"
            class="text-muted-foreground hover:text-foreground data-[active=true]:text-foreground text-[0.8rem] no-underline transition-colors data-[depth=3]:pl-4 data-[depth=4]:pl-6"
            data-active="false" data-depth="2">
            _seq_decoder
        </a>
        

        
        <a href="#acvr._pyav_backend.PyAVVideoBackend._seq_frame_index"
            class="text-muted-foreground hover:text-foreground data-[active=true]:text-foreground text-[0.8rem] no-underline transition-colors data-[depth=3]:pl-4 data-[depth=4]:pl-6"
            data-active="false" data-depth="2">
            _seq_frame_index
        </a>
        

        
        <a href="#acvr._pyav_backend.PyAVVideoBackend._seq_stream"
            class="text-muted-foreground hover:text-foreground data-[active=true]:text-foreground text-[0.8rem] no-underline transition-colors data-[depth=3]:pl-4 data-[depth=4]:pl-6"
            data-active="false" data-depth="2">
            _seq_stream
        </a>
        

        
        <a href="#acvr._pyav_backend.PyAVVideoBackend._start_pts"
            class="text-muted-foreground hover:text-foreground data-[active=true]:text-foreground text-[0.8rem] no-underline transition-colors data-[depth=3]:pl-4 data-[depth=4]:pl-6"
            data-active="false" data-depth="2">
            _start_pts
        </a>
        

        
        <a href="#acvr._pyav_backend.PyAVVideoBackend._stream"
            class="text-muted-foreground hover:text-foreground data-[active=true]:text-foreground text-[0.8rem] no-underline transition-colors data-[depth=3]:pl-4 data-[depth=4]:pl-6"
            data-active="false" data-depth="2">
            _stream
        </a>
        

        
        <a href="#acvr._pyav_backend.PyAVVideoBackend._thread_count"
            class="text-muted-foreground hover:text-foreground data-[active=true]:text-foreground text-[0.8rem] no-underline transition-colors data-[depth=3]:pl-4 data-[depth=4]:pl-6"
            data-active="false" data-depth="2">
            _thread_count
        </a>
        

        
        <a href="#acvr._pyav_backend.PyAVVideoBackend._threading"
            class="text-muted-foreground hover:text-foreground data-[active=true]:text-foreground text-[0.8rem] no-underline transition-colors data-[depth=3]:pl-4 data-[depth=4]:pl-6"
            data-active="false" data-depth="2">
            _threading
        </a>
        

        
        <a href="#acvr._pyav_backend.PyAVVideoBackend._time_base"
            class="text-muted-foreground hover:text-foreground data-[active=true]:text-foreground text-[0.8rem] no-underline transition-colors data-[depth=3]:pl-4 data-[depth=4]:pl-6"
            data-active="false" data-depth="2">
            _time_base
        </a>
        

        
        <a href="#acvr._pyav_backend.PyAVVideoBackend.current_frame_pos"
            class="text-muted-foreground hover:text-foreground data-[active=true]:text-foreground text-[0.8rem] no-underline transition-colors data-[depth=3]:pl-4 data-[depth=4]:pl-6"
            data-active="false" data-depth="2">
            current_frame_pos
        </a>
        

        
        <a href="#acvr._pyav_backend.PyAVVideoBackend.fourcc"
            class="text-muted-foreground hover:text-foreground data-[active=true]:text-foreground text-[0.8rem] no-underline transition-colors data-[depth=3]:pl-4 data-[depth=4]:pl-6"
            data-active="false" data-depth="2">
            fourcc
        </a>
        

        
        <a href="#acvr._pyav_backend.PyAVVideoBackend.frame_format"
            class="text-muted-foreground hover:text-foreground data-[active=true]:text-foreground text-[0.8rem] no-underline transition-colors data-[depth=3]:pl-4 data-[depth=4]:pl-6"
            data-active="false" data-depth="2">
            frame_format
        </a>
        

        
        <a href="#acvr._pyav_backend.PyAVVideoBackend.frame_height"
            class="text-muted-foreground hover:text-foreground data-[active=true]:text-foreground text-[0.8rem] no-underline transition-colors data-[depth=3]:pl-4 data-[depth=4]:pl-6"
            data-active="false" data-depth="2">
            frame_height
        </a>
        

        
        <a href="#acvr._pyav_backend.PyAVVideoBackend.frame_rate"
            class="text-muted-foreground hover:text-foreground data-[active=true]:text-foreground text-[0.8rem] no-underline transition-colors data-[depth=3]:pl-4 data-[depth=4]:pl-6"
            data-active="false" data-depth="2">
            frame_rate
        </a>
        

        
        <a href="#acvr._pyav_backend.PyAVVideoBackend.frame_shape"
            class="text-muted-foreground hover:text-foreground data-[active=true]:text-foreground text-[0.8rem] no-underline transition-colors data-[depth=3]:pl-4 data-[depth=4]:pl-6"
            data-active="false" data-depth="2">
            frame_shape
        </a>
        

        
        <a href="#acvr._pyav_backend.PyAVVideoBackend.frame_width"
            class="text-muted-foreground hover:text-foreground data-[active=true]:text-foreground text-[0.8rem] no-underline transition-colors data-[depth=3]:pl-4 data-[depth=4]:pl-6"
            data-active="false" data-depth="2">
            frame_width
        </a>
        

        
        <a href="#acvr._pyav_backend.PyAVVideoBackend.nominal_frame_rate"
            class="text-muted-foreground hover:text-foreground data-[active=true]:text-foreground text-[0.8rem] no-underline transition-colors data-[depth=3]:pl-4 data-[depth=4]:pl-6"
            data-active="false" data-depth="2">
            nominal_frame_rate
        </a>
        

        
        <a href="#acvr._pyav_backend.PyAVVideoBackend.number_of_frames"
            class="text-muted-foreground hover:text-foreground data-[active=true]:text-foreground text-[0.8rem] no-underline transition-colors data-[depth=3]:pl-4 data-[depth=4]:pl-6"
            data-active="false" data-depth="2">
            number_of_frames
        </a>
        

        
        <a href="#acvr._pyav_backend.PyAVVideoBackend.__enter__"
            class="text-muted-foreground hover:text-foreground data-[active=true]:text-foreground text-[0.8rem] no-underline transition-colors data-[depth=3]:pl-4 data-[depth=4]:pl-6"
            data-active="false" data-depth="2">
            __enter__
        </a>
        

        
        <a href="#acvr._pyav_backend.PyAVVideoBackend.__exit__"
            class="text-muted-foreground hover:text-foreground data-[active=true]:text-foreground text-[0.8rem] no-underline transition-colors data-[depth=3]:pl-4 data-[depth=4]:pl-6"
            data-active="false" data-depth="2">
            __exit__
        </a>
        

        
        <a href="#acvr._pyav_backend.PyAVVideoBackend.__init__"
            class="text-muted-foreground hover:text-foreground data-[active=true]:text-foreground text-[0.8rem] no-underline transition-colors data-[depth=3]:pl-4 data-[depth=4]:pl-6"
            data-active="false" data-depth="2">
            __init__
        </a>
        

        
        <a href="#acvr._pyav_backend.PyAVVideoBackend._bucket_key"
            class="text-muted-foreground hover:text-foreground data-[active=true]:text-foreground text-[0.8rem] no-underline transition-colors data-[depth=3]:pl-4 data-[depth=4]:pl-6"
            data-active="false" data-depth="2">
            _bucket_key
        </a>
        

        
        <a href="#acvr._pyav_backend.PyAVVideoBackend._compute_fourcc"
            class="text-muted-foreground hover:text-foreground data-[active=true]:text-foreground text-[0.8rem] no-underline transition-colors data-[depth=3]:pl-4 data-[depth=4]:pl-6"
            data-active="false" data-depth="2">
            _compute_fourcc
        </a>
        

        
        <a href="#acvr._pyav_backend.PyAVVideoBackend._compute_frame_rate"
            class="text-muted-foreground hover:text-foreground data-[active=true]:text-foreground text-[0.8rem] no-underline transition-colors data-[depth=3]:pl-4 data-[depth=4]:pl-6"
            data-active="false" data-depth="2">
            _compute_frame_rate
        </a>
        

        
        <a href="#acvr._pyav_backend.PyAVVideoBackend._compute_nominal_frame_rate"
            class="text-muted-foreground hover:text-foreground data-[active=true]:text-foreground text-[0.8rem] no-underline transition-colors data-[depth=3]:pl-4 data-[depth=4]:pl-6"
            data-active="false" data-depth="2">
            _compute_nominal_frame_rate
        </a>
        

        
        <a href="#acvr._pyav_backend.PyAVVideoBackend._configure_codec_context"
            class="text-muted-foreground hover:text-foreground data-[active=true]:text-foreground text-[0.8rem] no-underline transition-colors data-[depth=3]:pl-4 data-[depth=4]:pl-6"
            data-active="false" data-depth="2">
            _configure_codec_context
        </a>
        

        
        <a href="#acvr._pyav_backend.PyAVVideoBackend._ensure_fast_container"
            class="text-muted-foreground hover:text-foreground data-[active=true]:text-foreground text-[0.8rem] no-underline transition-colors data-[depth=3]:pl-4 data-[depth=4]:pl-6"
            data-active="false" data-depth="2">
            _ensure_fast_container
        </a>
        

        
        <a href="#acvr._pyav_backend.PyAVVideoBackend._ensure_frame_pts"
            class="text-muted-foreground hover:text-foreground data-[active=true]:text-foreground text-[0.8rem] no-underline transition-colors data-[depth=3]:pl-4 data-[depth=4]:pl-6"
            data-active="false" data-depth="2">
            _ensure_frame_pts
        </a>
        

        
        <a href="#acvr._pyav_backend.PyAVVideoBackend._ensure_seq_container"
            class="text-muted-foreground hover:text-foreground data-[active=true]:text-foreground text-[0.8rem] no-underline transition-colors data-[depth=3]:pl-4 data-[depth=4]:pl-6"
            data-active="false" data-depth="2">
            _ensure_seq_container
        </a>
        

        
        <a href="#acvr._pyav_backend.PyAVVideoBackend._fast_frame_to_pts"
            class="text-muted-foreground hover:text-foreground data-[active=true]:text-foreground text-[0.8rem] no-underline transition-colors data-[depth=3]:pl-4 data-[depth=4]:pl-6"
            data-active="false" data-depth="2">
            _fast_frame_to_pts
        </a>
        

        
        <a href="#acvr._pyav_backend.PyAVVideoBackend._fast_rewind"
            class="text-muted-foreground hover:text-foreground data-[active=true]:text-foreground text-[0.8rem] no-underline transition-colors data-[depth=3]:pl-4 data-[depth=4]:pl-6"
            data-active="false" data-depth="2">
            _fast_rewind
        </a>
        

        
        <a href="#acvr._pyav_backend.PyAVVideoBackend._flush_decoder"
            class="text-muted-foreground hover:text-foreground data-[active=true]:text-foreground text-[0.8rem] no-underline transition-colors data-[depth=3]:pl-4 data-[depth=4]:pl-6"
            data-active="false" data-depth="2">
            _flush_decoder
        </a>
        

        
        <a href="#acvr._pyav_backend.PyAVVideoBackend._frame_time_s"
            class="text-muted-foreground hover:text-foreground data-[active=true]:text-foreground text-[0.8rem] no-underline transition-colors data-[depth=3]:pl-4 data-[depth=4]:pl-6"
            data-active="false" data-depth="2">
            _frame_time_s
        </a>
        

        
        <a href="#acvr._pyav_backend.PyAVVideoBackend._keyframe_index_at_or_before_pts"
            class="text-muted-foreground hover:text-foreground data-[active=true]:text-foreground text-[0.8rem] no-underline transition-colors data-[depth=3]:pl-4 data-[depth=4]:pl-6"
            data-active="false" data-depth="2">
            _keyframe_index_at_or_before_pts
        </a>
        

        
        <a href="#acvr._pyav_backend.PyAVVideoBackend._keyframe_index_for_time_fast"
            class="text-muted-foreground hover:text-foreground data-[active=true]:text-foreground text-[0.8rem] no-underline transition-colors data-[depth=3]:pl-4 data-[depth=4]:pl-6"
            data-active="false" data-depth="2">
            _keyframe_index_for_time_fast
        </a>
        

        
        <a href="#acvr._pyav_backend.PyAVVideoBackend._keyframe_index_nearest_pts"
            class="text-muted-foreground hover:text-foreground data-[active=true]:text-foreground text-[0.8rem] no-underline transition-colors data-[depth=3]:pl-4 data-[depth=4]:pl-6"
            data-active="false" data-depth="2">
            _keyframe_index_nearest_pts
        </a>
        

        
        <a href="#acvr._pyav_backend.PyAVVideoBackend._pts_to_frame_number"
            class="text-muted-foreground hover:text-foreground data-[active=true]:text-foreground text-[0.8rem] no-underline transition-colors data-[depth=3]:pl-4 data-[depth=4]:pl-6"
            data-active="false" data-depth="2">
            _pts_to_frame_number
        </a>
        

        
        <a href="#acvr._pyav_backend.PyAVVideoBackend._pts_to_secs"
            class="text-muted-foreground hover:text-foreground data-[active=true]:text-foreground text-[0.8rem] no-underline transition-colors data-[depth=3]:pl-4 data-[depth=4]:pl-6"
            data-active="false" data-depth="2">
            _pts_to_secs
        </a>
        

        
        <a href="#acvr._pyav_backend.PyAVVideoBackend._read_frame_at_index"
            class="text-muted-foreground hover:text-foreground data-[active=true]:text-foreground text-[0.8rem] no-underline transition-colors data-[depth=3]:pl-4 data-[depth=4]:pl-6"
            data-active="false" data-depth="2">
            _read_frame_at_index
        </a>
        

        
        <a href="#acvr._pyav_backend.PyAVVideoBackend._read_frame_by_pts"
            class="text-muted-foreground hover:text-foreground data-[active=true]:text-foreground text-[0.8rem] no-underline transition-colors data-[depth=3]:pl-4 data-[depth=4]:pl-6"
            data-active="false" data-depth="2">
            _read_frame_by_pts
        </a>
        

        
        <a href="#acvr._pyav_backend.PyAVVideoBackend._read_frame_fast_like"
            class="text-muted-foreground hover:text-foreground data-[active=true]:text-foreground text-[0.8rem] no-underline transition-colors data-[depth=3]:pl-4 data-[depth=4]:pl-6"
            data-active="false" data-depth="2">
            _read_frame_fast_like
        </a>
        

        
        <a href="#acvr._pyav_backend.PyAVVideoBackend._read_frame_fast_opencv_pyav"
            class="text-muted-foreground hover:text-foreground data-[active=true]:text-foreground text-[0.8rem] no-underline transition-colors data-[depth=3]:pl-4 data-[depth=4]:pl-6"
            data-active="false" data-depth="2">
            _read_frame_fast_opencv_pyav
        </a>
        

        
        <a href="#acvr._pyav_backend.PyAVVideoBackend._read_frame_fast_simple"
            class="text-muted-foreground hover:text-foreground data-[active=true]:text-foreground text-[0.8rem] no-underline transition-colors data-[depth=3]:pl-4 data-[depth=4]:pl-6"
            data-active="false" data-depth="2">
            _read_frame_fast_simple
        </a>
        

        
        <a href="#acvr._pyav_backend.PyAVVideoBackend._secs_to_pts"
            class="text-muted-foreground hover:text-foreground data-[active=true]:text-foreground text-[0.8rem] no-underline transition-colors data-[depth=3]:pl-4 data-[depth=4]:pl-6"
            data-active="false" data-depth="2">
            _secs_to_pts
        </a>
        

        
        <a href="#acvr._pyav_backend.PyAVVideoBackend._seek_seq_to_pts"
            class="text-muted-foreground hover:text-foreground data-[active=true]:text-foreground text-[0.8rem] no-underline transition-colors data-[depth=3]:pl-4 data-[depth=4]:pl-6"
            data-active="false" data-depth="2">
            _seek_seq_to_pts
        </a>
        

        
        <a href="#acvr._pyav_backend.PyAVVideoBackend._seek_to_pts"
            class="text-muted-foreground hover:text-foreground data-[active=true]:text-foreground text-[0.8rem] no-underline transition-colors data-[depth=3]:pl-4 data-[depth=4]:pl-6"
            data-active="false" data-depth="2">
            _seek_to_pts
        </a>
        

        
        <a href="#acvr._pyav_backend.PyAVVideoBackend.build_keyframe_index"
            class="text-muted-foreground hover:text-foreground data-[active=true]:text-foreground text-[0.8rem] no-underline transition-colors data-[depth=3]:pl-4 data-[depth=4]:pl-6"
            data-active="false" data-depth="2">
            build_keyframe_index
        </a>
        

        
        <a href="#acvr._pyav_backend.PyAVVideoBackend.close"
            class="text-muted-foreground hover:text-foreground data-[active=true]:text-foreground text-[0.8rem] no-underline transition-colors data-[depth=3]:pl-4 data-[depth=4]:pl-6"
            data-active="false" data-depth="2">
            close
        </a>
        

        
        <a href="#acvr._pyav_backend.PyAVVideoBackend.frame_at_index"
            class="text-muted-foreground hover:text-foreground data-[active=true]:text-foreground text-[0.8rem] no-underline transition-colors data-[depth=3]:pl-4 data-[depth=4]:pl-6"
            data-active="false" data-depth="2">
            frame_at_index
        </a>
        

        
        <a href="#acvr._pyav_backend.PyAVVideoBackend.index_from_pts"
            class="text-muted-foreground hover:text-foreground data-[active=true]:text-foreground text-[0.8rem] no-underline transition-colors data-[depth=3]:pl-4 data-[depth=4]:pl-6"
            data-active="false" data-depth="2">
            index_from_pts
        </a>
        

        
        <a href="#acvr._pyav_backend.PyAVVideoBackend.index_from_time"
            class="text-muted-foreground hover:text-foreground data-[active=true]:text-foreground text-[0.8rem] no-underline transition-colors data-[depth=3]:pl-4 data-[depth=4]:pl-6"
            data-active="false" data-depth="2">
            index_from_time
        </a>
        

        
        <a href="#acvr._pyav_backend.PyAVVideoBackend.iter_frames"
            class="text-muted-foreground hover:text-foreground data-[active=true]:text-foreground text-[0.8rem] no-underline transition-colors data-[depth=3]:pl-4 data-[depth=4]:pl-6"
            data-active="false" data-depth="2">
            iter_frames
        </a>
        

        
        <a href="#acvr._pyav_backend.PyAVVideoBackend.pts_at_index"
            class="text-muted-foreground hover:text-foreground data-[active=true]:text-foreground text-[0.8rem] no-underline transition-colors data-[depth=3]:pl-4 data-[depth=4]:pl-6"
            data-active="false" data-depth="2">
            pts_at_index
        </a>
        

        
        <a href="#acvr._pyav_backend.PyAVVideoBackend.read_frame"
            class="text-muted-foreground hover:text-foreground data-[active=true]:text-foreground text-[0.8rem] no-underline transition-colors data-[depth=3]:pl-4 data-[depth=4]:pl-6"
            data-active="false" data-depth="2">
            read_frame
        </a>
        

        
        <a href="#acvr._pyav_backend.PyAVVideoBackend.read_frame_at"
            class="text-muted-foreground hover:text-foreground data-[active=true]:text-foreground text-[0.8rem] no-underline transition-colors data-[depth=3]:pl-4 data-[depth=4]:pl-6"
            data-active="false" data-depth="2">
            read_frame_at
        </a>
        

        
        <a href="#acvr._pyav_backend.PyAVVideoBackend.read_frame_fast"
            class="text-muted-foreground hover:text-foreground data-[active=true]:text-foreground text-[0.8rem] no-underline transition-colors data-[depth=3]:pl-4 data-[depth=4]:pl-6"
            data-active="false" data-depth="2">
            read_frame_fast
        </a>
        

        
        <a href="#acvr._pyav_backend.PyAVVideoBackend.read_keyframe_at"
            class="text-muted-foreground hover:text-foreground data-[active=true]:text-foreground text-[0.8rem] no-underline transition-colors data-[depth=3]:pl-4 data-[depth=4]:pl-6"
            data-active="false" data-depth="2">
            read_keyframe_at
        </a>
        

        
        <a href="#acvr._pyav_backend.PyAVVideoBackend.read_next_frame"
            class="text-muted-foreground hover:text-foreground data-[active=true]:text-foreground text-[0.8rem] no-underline transition-colors data-[depth=3]:pl-4 data-[depth=4]:pl-6"
            data-active="false" data-depth="2">
            read_next_frame
        </a>
        

        
        <a href="#acvr._pyav_backend.PyAVVideoBackend.reset_sequence"
            class="text-muted-foreground hover:text-foreground data-[active=true]:text-foreground text-[0.8rem] no-underline transition-colors data-[depth=3]:pl-4 data-[depth=4]:pl-6"
            data-active="false" data-depth="2">
            reset_sequence
        </a>
        

        
        <a href="#acvr._pyav_backend.PyAVVideoBackend.time_at_index"
            class="text-muted-foreground hover:text-foreground data-[active=true]:text-foreground text-[0.8rem] no-underline transition-colors data-[depth=3]:pl-4 data-[depth=4]:pl-6"
            data-active="false" data-depth="2">
            time_at_index
        </a>
        

        
        
        
        

    </div>
    <div class="h-12"></div>
</div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </main>
        <footer view-transition-name="footer"
    class="group-has-[.section-soft]/body:bg-surface/40 3xl:fixed:bg-transparent dark:bg-transparent">
    <div class="container-wrapper px-4 xl:px-6">
        <div class="flex h-(--footer-height) items-center justify-between">
            <div class="text-muted-foreground w-full text-center text-xs leading-loose sm:text-sm">
                
                <a href="https://github.com/asiffer/mkdocs-shadcn">shadcn theme</a> provided by
                <a href="https://github.com/asiffer">@asiffer</a>
            </div>
        </div>
    </div>
</footer>
    </div>
     

<script src="../search/main.js"></script>


    

    <script src="../js/copy-button.js"></script>
    <script>updatePygmentsStylesheet();</script>
    
    
    <script>
    for (const el of document.querySelectorAll(
        ".typography .doc code.language-python",
    )) {
        el.classList.add("codehilite");
    }

    for (const el of document.querySelectorAll("article .doc .doc-contents")) {
        el.innerHTML = el.innerHTML.trim();
    }
</script>
    
    
    <script type="speculationrules">
{
  "prerender": [
    {
      "where": {
          "selector_matches": ["#next-button", "#previous-button"],
      }
    }
  ]
}
</script>
</body>

</html>